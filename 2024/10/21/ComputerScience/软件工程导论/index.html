<!-- build time:Sun Nov 03 2024 15:22:41 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><meta name="referrer" content="no-referrer"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Shoka" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="Shoka" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="Shoka" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="http://example.com/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"><title>软件工程导论 - 计算机科学 | Suivez Shoka = Shoka</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">软件工程导论</h1><div class="meta"><span class="item" title="创建时间：2024-10-21 15:42:28"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-10-21T15:42:28+08:00">2024-10-21</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Suivez Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn//large/0072Vf1pgy1fodqidu9iij315o0tg7wh.jpg"></li><li class="item" data-background-image="https://images3.alphacoders.com/127/1271502.jpg"></li><li class="item" data-background-image="https://images4.alphacoders.com/227/227838.jpg"></li><li class="item" data-background-image="https://images4.alphacoders.com/973/973967.jpg"></li><li class="item" data-background-image="https://images8.alphacoders.com/129/1296002.jpg"></li><li class="item" data-background-image="https://images2.alphacoders.com/110/1109233.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerscience/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Suivez"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Shoka"></span><div class="body md" itemprop="articleBody"><h1 id="第一章-软件及其特点"><a class="anchor" href="#第一章-软件及其特点">#</a> 第一章 软件及其特点</h1><h2 id="软件"><a class="anchor" href="#软件">#</a> 软件</h2><p><strong>编写程序步骤</strong></p><ul><li>分析软件需求：文档 数据</li><li>设计软件系统：文档 数据</li><li>编写代码程序：数据 代码</li></ul><blockquote><p>不可或缺，相互依存</p></blockquote><p><strong>软件</strong></p><p>软件是指在计算机系统的支持下，能够完成特定功能与性能的<ins class="dot">程序、数据和相关文档</ins></p><p><strong>文档</strong></p><p>记录软件开发活动和阶段性成果，软件配置以及变更的阐述性资料</p><ul><li>定义和理解软件</li><li>记录软件开发成果</li><li>辅助不同人员间的交流</li></ul><blockquote><p>软件需求文档、软件设计文档、软件测试文档、软件用户手册......</p><p>目的：阐述、发现问题、交流、管理</p></blockquote><p><strong>数据</strong></p><p>数据是程序的加工处理对象和结果</p><p>✏️ 软件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\ne</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 程序	开发软件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\ne</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 编写程序</p><hr><p><ins>软件的规模和复杂性意味着要采用行之有效的方法 ——<strong> 工程方法</strong></ins></p><h3 id="软件生命周期"><a class="anchor" href="#软件生命周期">#</a> 软件生命周期</h3><p>从<strong>提出开发</strong>开始到<strong>开发出系统</strong>、<strong>运行维护</strong>以及<strong>最终退役</strong>的全过程</p><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    A<span class="token text string">[需求分析]</span> <span class="token arrow operator">--></span> B<span class="token text string">[软件设计]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    B <span class="token arrow operator">--></span> C<span class="token text string">[编码实现]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    C <span class="token arrow operator">--></span> D<span class="token text string">[软件测试]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    D <span class="token arrow operator">--></span> E<span class="token text string">[部署使用]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    E <span class="token arrow operator">--></span> F<span class="token text string">[使用维护]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="软件特点"><a class="anchor" href="#软件特点">#</a> 软件特点</h3><ul><li><p><strong>逻辑性</strong></p><ul><li>逻辑产品，思维获得的结果，不会磨损和老化</li></ul></li><li><p><strong>复杂性</strong></p><ul><li>规模大、运行复杂</li></ul></li><li><p>设计开发</p></li><li><p>易变性</p></li><li><p>缺陷隐藏性</p></li></ul><h3 id="软件分类"><a class="anchor" href="#软件分类">#</a> 软件分类</h3><p>应用软件、系统软件、支撑软件（辅助软件开发和运维）</p><h2 id="开源软件"><a class="anchor" href="#开源软件">#</a> 开源软件</h2><p><strong>闭源软件</strong></p><p>软件代码不对用户开放的一类软件，购买软件时只提供可运行软件或服务，没有提供源代码</p><blockquote><p>Windows、Office</p><p>IBM、Oracle</p></blockquote><p><strong>开源软件</strong></p><p>一种源代码可以<strong>自由获取和传播</strong>的计算机软件，其拥有者通过开源许可证赋予被许可人对软件<strong>进行使用、修改和传播</strong>的权力</p><ul><li>好处：自由传播、激发创作者热情、降低成本（free of charge）</li></ul><blockquote><p>Linux、Mysql、Firefox</p></blockquote><blockquote><p>github, gitee, stack overflow</p></blockquote><h2 id="软件质量"><a class="anchor" href="#软件质量">#</a> 软件质量</h2><p>软件质量是指软件满足给定需求的程度，它是<strong>产品生命线</strong></p><p>可信软件的基本要求：</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_0" checked disabled><label for="cbx_0">安全性</label></li><li class="task-list-item"><input type="checkbox" id="cbx_1" checked disabled><label for="cbx_1">韧性 (Resilience)</label></li><li class="task-list-item"><input type="checkbox" id="cbx_2" checked disabled><label for="cbx_2">隐私性</label></li><li class="task-list-item"><input type="checkbox" id="cbx_3" checked disabled><label for="cbx_3">可靠性</label></li></ul><h2 id="当前软件特征的变化"><a class="anchor" href="#当前软件特征的变化">#</a> 当前软件特征的变化</h2><p><strong>地位和作用</strong>：无处不在，创新工具，使能技术和重要利器，关键性基础设施</p><p><strong>运行环境</strong>：</p><ul><li><p>从前端的 PC 终端、可穿戴设备、智能手机到后端的云中心、高性能计算中心</p></li><li><p>从孤立、独立、局域和可控的计算环境到分布、开发、动态、难控、无处不在的计算环境</p></li></ul><hr><p><strong>软件形态</strong></p><ul><li><p>系统之系统</p><p>诸多系统联盟和组合而成</p></li><li><p>生态系统</p><p>社会、信息、物理等要素共存</p></li><li><p>同构异构多样的系统联盟</p><p>要素异构，客观存在也是必然</p><blockquote><p>大规模复杂信息技术系统是由大量相对独立、自我控制和管理的系统组装而成一系统联盟</p><p><ins>开发系统联盟需要采用社会技术观点，借助系统工程的方法</ins></p></blockquote></li><li><p>非封闭环境 or 系统，是开发环境动态适应系统</p><p>环境和系统相互作用，要素、关系、联盟等持续变化，边界不明确</p></li><li><p><strong>动态演化系统</strong></p></li></ul><p><strong>软件子系统</strong></p><p>由一组面向任务，服务于不同对象的<strong>子系统</strong>构成</p><blockquote><p>每个子系统<strong>独立运作</strong>、通过<strong>互相交互</strong>实现全局任务</p></blockquote><p><strong>分布式系统四大形态</strong></p><table><thead><tr><th>对等计算</th><th>区块链</th><th>网格计算</th><th>云计算</th></tr></thead><tbody><tr><td>泛化（old）</td><td>泛化（new）</td><td>集中化（old）</td><td>集中化（new）</td></tr></tbody></table><p><strong>生态系统</strong></p><ul><li><p>运行生态</p><blockquote><p>软件的运行需要依靠 “生态” 的支撑，从计算和物理设备、社会系统到 OS 和运行环境</p></blockquote></li><li><p>演化生态</p><blockquote><p>软件的演化基于特定的 “生态” 支撑 ，从最初的 “源头” 到最新 “版本”</p></blockquote></li><li><p>人员生态</p><blockquote><p>涉及到大量、开放的介入人员，使用者、开发者、运维者等</p></blockquote></li></ul><div class="note info"><p><strong>软件生态：共同环境 + 诸多要素 + 独立演化 + 相互依存</strong></p></div><p><strong>软件系统的应用及示例</strong></p><ul><li>高性能计算 、信息物理系统 、智能机器人 、云计算 、健康医疗 、城市交通 、军事信息系统 、航空航天</li></ul><h2 id="summary"><a class="anchor" href="#summary">#</a> Summary</h2><ul><li><p><strong>软件</strong></p><p>程序 + 文档 + 数据</p></li><li><p><strong>软件特点</strong></p><p>逻辑产品、设计开发、需求易变、系统复杂、缺陷隐蔽</p></li><li><p><strong>开源软件</strong></p><p>代码可自由获取和传播，需遵循许可证，充分利用开源软件</p></li><li><p><strong>软件质量</strong></p><p>多要素，如正确性、可靠性、可信性等</p></li><li><p><strong>软件发生的变化</strong></p><p>地位和作用，形态和复杂性，运行环境，系统规模</p></li></ul><h1 id="第二章-软件工程发展脉络"><a class="anchor" href="#第二章-软件工程发展脉络">#</a> 第二章 软件工程发展脉络</h1><h2 id="软件工程产生背景"><a class="anchor" href="#软件工程产生背景">#</a> 软件工程产生背景</h2><ul><li>作坊式的个人创作<ul><li><strong>依靠个人能力</strong></li><li><strong>缺乏合作</strong></li><li>关注计算存储时空利用， 精雕细琢</li><li>程序规模小且功能单一</li><li><strong>无系统性方法和标准流程</strong></li></ul></li><li>大规模软件开发<ul><li>当软件规模越大，上述挑战就越突出，面临的困难也就越多（规模大、复杂性高的软件）<ul><li>代码量、人员管理、隐蔽性错误越积越多</li></ul></li></ul></li></ul><p><img data-src="https://i0.hdslb.com/bfs/article/8d84c410fd8087eb534064bcea23bf89490570799.png" alt="zhiliang"></p><p><strong>Leading to</strong></p><ul><li><span class="red"><strong>软件危机</strong>：进度延迟、质量不稳定、成本过高、维护困难、失败风险大</span></li></ul><hr><p><strong>软件危机产生的根源</strong></p><ul><li>对软件这样一类<strong>复杂和特殊系统</strong>的认识不清<ul><li>软件是新生事物，对其特点、规律性和复杂性认识不够</li></ul></li><li>没有找到<strong>支持软件系统开发的有效方法</strong><ul><li>基础理论、关键技术、开发过程、支撑工具等</li></ul></li><li>缺乏成功软件开发<strong>实践</strong>以及相应的开发<strong>经验</strong><ul><li><ins>系统总结、认真分析、充分借鉴、吸取教训</ins></li></ul></li></ul><blockquote><p>软件开发迫切需要理论和方法指导，软件工程应运而生！</p></blockquote><h2 id="软件工程基本内涵"><a class="anchor" href="#软件工程基本内涵">#</a> 软件工程基本内涵</h2><p>软件工程的诞生</p><p><strong>时间</strong>：1968，<strong>地点</strong>：西德南部小城，<strong>事件</strong>：NATO 科技委出资召开的会议，<strong>人物</strong>：11 个国家 50 位代表参加</p><p><strong>主题</strong>：如何解决软件危机，<strong>成果</strong>：提出了软件工程</p><p><strong>软件工程产生动机</strong></p><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> TD<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    A<span class="token text string">[软件工程]</span> <span class="token arrow operator">--></span><span class="token label property">|解决软件危机|</span> B<span class="token text string">[软件系统开发]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">subgraph</span> 要求<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        C1<span class="token text string">[快速]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        C2<span class="token text string">[高效]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        C3<span class="token text string">[低成本]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        C4<span class="token text string">[高质量]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    A <span class="token arrow operator">--></span> C1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    A <span class="token arrow operator">--></span> C2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    A <span class="token arrow operator">--></span> C3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    A <span class="token arrow operator">--></span> C4<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="何为软件工程"><a class="anchor" href="#何为软件工程">#</a> 何为软件工程</h3><p>软件工程：将<strong>系统的、规范的、可量化</strong>的方法应用于软件的开发、运行和维护的过程</p><p>软件是产品 (Product)：面向用户，存在质量、成本、利润等特征</p><p>软件开发是一项工程 (Project)：存在约束，需要质量保证，进行组织管理</p><p>要按工程化方法来组织软件生产</p><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>A<span class="token text string">[约束]</span><span class="token arrow operator">--></span>B<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>B<span class="token text string">[过程]</span><span class="token arrow operator">--></span>C<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>C<span class="token text string">[质量]</span><span class="token arrow operator">--></span>D<span class="token text string">[成本]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>软件开发方式的改变：从个体作坊式行为 ➡️ 基于团队的协同开发方式</p><h3 id="软件工程三要素"><a class="anchor" href="#软件工程三要素">#</a> 软件工程三要素</h3><p><img data-src="https://i0.hdslb.com/bfs/article/3913d963dd13223186052ab00236b854490570799.png" alt="3attribute"></p><h4 id="过程"><a class="anchor" href="#过程">#</a> 过程</h4><p>从<strong>管理</strong>的视角，回答软件开发、运行和维护需要<strong>开展哪些工作、按照什么样的步骤和次序来开展工作</strong></p><h4 id="方法学"><a class="anchor" href="#方法学">#</a> 方法学</h4><p>从<strong>技术</strong>的视角，回答软件开发、运行和维护如何做的问题</p><p>为软件开发过程中的各项开发和维护活动提供<strong>系统性、规范性的技术支持</strong></p><div class="note primary 典型成果"><p>✏️ 结构化软件开发方法学 ✏️ 面向对象软件开发方法学 ✏️ 基于构件的软件开发方法学</p></div><h4 id="工具"><a class="anchor" href="#工具">#</a> 工具</h4><p>从<strong>工具辅助</strong>的视角，主要回答如何借助工具来<strong>辅助软件开发、运行和维护</strong>的问题</p><p>帮助软件开发人员更为高效地运用<strong>软件开发方法学</strong>来完成软件开发过程中的各项工作，<ins>提高软件开发效率和质量， 加快软件交付进度</ins>。</p><blockquote><p>如需求分析、软件设计、编码实现、软件测试、部署运行、软件 维护、项目管理、质量保证等，简化软件开发任务</p></blockquote><h3 id="软件开发的本质"><a class="anchor" href="#软件开发的本质">#</a> 软件开发的本质</h3><p><mark>软件开发 = 软件创作 + 软件生产</mark></p><p>基于软件开发者的经验和技 能，借助于智慧，进行自由创新；基于工程化的手段，遵循约束和规范</p><ul><li><p>软件工程目标</p><p>在<strong>成本、进度</strong>等约束下，指导<strong>软件开发和运维</strong>，开发出满足用户要求的足够好软件</p></li><li><p><span class="green">软件工程原则</span></p><ol><li><p>抽象和建模</p><p><strong>抽象</strong>：将与相关开发活动所关注的要素提取出来，不关心的要素扔掉，形成与该开发活动相关的软件要素</p><p><strong>建模</strong>：基于特定的抽象，借助于<strong>建模语言</strong>（如数据流图、UML 等），<strong>建立起基于这些抽象的软件模型</strong>，进而促进对软件系统的 准确理解</p></li><li><p>模块化</p></li></ol><ul><li>将软件系统的功能分<strong>解和实现为若干个模块</strong>，每个模块具有独立 的功能，模块之间通过接口进行调用和访问。</li><li><strong>模块内部高内聚，模块间松耦合</strong></li></ul><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>A<span class="token text string">[函数和过程]</span><span class="token arrow operator">--></span>B<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>B<span class="token text string">[对象类]</span><span class="token arrow operator">--></span>C<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>C<span class="token text string">[软构件]</span><span class="token arrow operator">--></span>D<span class="token text string">[服务及镜像]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ol start="3"><li><p>软件重用</p><ul><li><p>在软件开发过程中<strong>尽可能利用已有的软件资源和资产</strong>（如函数 库、类库、构件库、开源软件、代码片段等）来实现软件系统</p><ul><li>努力开发出<strong>可被再次重用的软件资源</strong>（如函数、类、构件等）</li></ul><div class="note info"><p>代码重用、设计重用、软件重用</p></div></li></ul></li><li><p>信息隐藏</p><ul><li>模块内部信息（如内部的语 句、变量等）<strong>对外不可见或不可访问</strong>，模块间仅仅交换那些为完成系统功能所必需交换的信息（如接口）</li></ul></li><li><p>关注点分离：每一项开发活动中聚焦于某个关注点，整合多个不同视点的开发结果</p></li><li><p><strong>分而治之</strong>：对复杂软件系统进行 分解，形成一组子系统；然后通过整合子系统的问题解决得到整个 系统的问题解；有助于简化复杂软件系统的开发，降低软件开发复杂性，从而提 高软件开发效率，确保复杂软件系统的质量。</p></li><li><p>双向追踪原则</p><ul><li>当某个软件制品发生变化时，<strong>一方面要追踪这种变化会对那些软件制品产生影响</strong>，进而指导相关的开发和维护工作，此为正向追踪；<strong>另一方面要追踪产生这种变化的来源</strong></li></ul></li><li><p>工具辅助：利用软件工具来辅助软件开发和维护工作是一项行之有效的方法</p></li></ol><p><code>工欲善其事必先利其器</code></p></li></ul><div class="note primary"><p><strong>软件工程原则</strong>: <ins><strong>抽象和建模、模块化、软件重用、信息隐藏、 关注点分离、分而治之、双向追踪、工具辅助</strong></ins></p></div><h2 id="软件工程的发展历程"><a class="anchor" href="#软件工程的发展历程">#</a> 软件工程的发展历程</h2><p><img data-src="https://i0.hdslb.com/bfs/article/cc91c667445a3b9e3d83a6867332f93e490570799.png" alt="软件工程的发展历程"></p><h3 id="软件工程发展的技术特点"><a class="anchor" href="#软件工程发展的技术特点">#</a> 软件工程发展的技术特点</h3><p><ins>抽象的层次越来越高、软件重用的粒度越来越大、软件开发理念的不断变化</ins></p><p>软件工程多学科交叉</p><p><strong>软件工程的变与不变</strong></p><ul><li>目标、基本原则不变；理解认识改变，手段方法改变，学科进一步交叉融合</li></ul><h2 id="summary-2"><a class="anchor" href="#summary-2">#</a> Summary</h2><ul><li><p><strong>软件工程产生的背景和目的</strong></p><p>软件危机，持续存在，关注点不同</p></li><li><p><strong>软件工程的本质</strong></p><ul><li><p>软件视为产品，软件开发视为工程、创作和生产相结合的过程</p></li><li><p>三要素：<span class="red">过程、方法学和工具</span></p></li><li><p>软件工程的基本原则</p><details class="success"><summary>总则</summary><div><p>抽象和建模、模块化、软件重用、信息隐藏、 关注点分离、分而治之、双向追踪、工具辅助</p></div></details></li></ul></li><li><p><strong>软件工程的发展</strong></p><p>不同阶段和时期，不同的思想和技术</p></li><li><p><strong>软件工程教育</strong></p><p>软件工程知识体系及课程特点</p></li></ul><h1 id="第三章-软件过程模型"><a class="anchor" href="#第三章-软件过程模型">#</a> 第三章 软件过程模型</h1><p><strong>review</strong></p><p>软件的<strong>概念</strong>：文档、数据和程序的集合</p><p>软件的<strong>特点</strong>：逻辑产品、需求多变、设计开发、缺陷隐蔽性</p><p>软件<strong>生命周期</strong>：经历多个不同的阶段</p><p>闭源软件和开源软件：实践状况及优势</p><p>软件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 程序；开发软件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 编写程序；</p><div class="note info"><p><strong>生命周期</strong>：从<strong>提出开发</strong>开始到<strong>开发出系统、运行维护以及最终退役</strong>的全过程</p></div><h2 id="何为软件过程模型"><a class="anchor" href="#何为软件过程模型">#</a> 何为软件过程模型</h2><h3 id="软件开发的特点"><a class="anchor" href="#软件开发的特点">#</a> 软件开发的特点</h3><p>✏️<strong>基于智力的协作过程</strong></p><ul><li>智力活动：基于逻辑思维来构造软件</li><li>交流协作：软件工程师、用户间的交流和讨论</li></ul><p>🪄<strong>软件项目内在复杂性</strong></p><ul><li>介入的人多、考虑的内容多、产生的制品多</li><li>不同要素间存在关联</li></ul><p>🎢<strong>循序渐进的开发过程</strong></p><ul><li>开展有序的开发活动，如编码、分析、设计</li><li>体现了工程的思想：按步骤、分阶段</li></ul><h3 id="软件过程"><a class="anchor" href="#软件过程">#</a> 软件过程</h3><ul><li>过程：获得 + 关系（次序……）</li><li><strong>软件过程</strong>：一系列有序软件<strong>开发活动</strong>（技术活动和管理活动）</li></ul><h3 id="软件过程模型-software-process-model"><a class="anchor" href="#软件过程模型-software-process-model">#</a> 软件过程模型 Software Process Model</h3><p>开发活动</p><ul><li>任务、目标、输入 和输出</li><li>投入人员、工具、资源 和成本等</li><li>活动间的关系和次序</li></ul><h2 id="有哪些软件过程模型"><a class="anchor" href="#有哪些软件过程模型">#</a> 有哪些软件过程模型</h2><p>瀑布模型、增量模型、迭代模型、原型模型、螺旋模型</p><div class="note info"><p>需要系统、规范性的软件过程模型的指导；每种软件过程模型有其各自的特点和适用的场所</p></div><h3 id="瀑布模型-waterfall-model"><a class="anchor" href="#瀑布模型-waterfall-model">#</a> 瀑布模型 Waterfall Model</h3><h4 id="waterfall"><a class="anchor" href="#waterfall">#</a> Waterfall</h4><ul><li><strong>需求分析→概要设计→详细设计→编码实现→集成测试→确认测试</strong></li><li>适合于需求易于定义、 不易变动的软件系统</li></ul><h4 id="detail"><a class="anchor" href="#detail">#</a> Detail</h4><p><strong>需求分析 (Requirement Analysis)</strong>—— 问题是什么</p><ul><li><p>定义软件需求，包括功能、非功能需求</p></li><li><p>产出：<span class="red">软件需求模型、软件需求文档、软件确认测试计划 ——<strong> 文档类的软件制品</strong></span></p></li></ul><p><strong>概要设计 (Architecture Design)</strong>—— 问题如何解决</p><ul><li>建立软件总体架构、制定集成测试计划</li><li>产出：<span class="red">软件概要设计模型、软件概要设计文档、软件集成测试计划 ——<strong> 文档类的软件制品</strong></span></li></ul><p><strong>详细设计 (Detailed Design)</strong>—— 问题如何解决</p><ul><li>设计模块内部细节 (算法、数据结构)，制订单元测试计划</li><li>产出：<span class="red">软件详细设计模型、软件详细设计文档、单元测试计划 ——<strong> 文档类的软件制品</strong></span></li></ul><p><strong>编程实现 (Implementation)</strong>—— 实际解决问题</p><ul><li>编写程序代码并进行单元测试和调试</li><li>产出：<span class="red">经过单元测试的源程序代码 ——<strong> 程序类的软件制品</strong></span></li></ul><p><strong>集成测试 (Integration Test)</strong>—— <ins class="dot">问题解决如何？软件有缺陷吗？</ins></p><ul><li>组装软件模块并进行测试以发现问题</li><li>产出：<span class="red">经过集成测试、修复缺陷的源程序代码，集成测试报告 ——<strong> 数据、文档和代码类的软件制品</strong></span></li></ul><p><strong>确认测试 (Validation Test)</strong>—— <ins class="dot">问题解决如何？软件有缺陷吗？</ins></p><ul><li>测试软件是否满足用户需求</li><li>产出：<span class="red">经过确认测试、修复缺陷后的代码，软件确认测试报告 ——<strong> 数据、文档和代码类的软件制品</strong></span></li></ul><h4 id="limitation"><a class="anchor" href="#limitation">#</a> Limitation</h4><p><mark>软件需求具有易变、多变的特点</mark></p><p>瀑布模型的<span class="red"><strong>需求确定，过于理想化，缺乏变通难以应对变化</strong></span></p><h4 id="改进的瀑布模型带反馈和回溯"><a class="anchor" href="#改进的瀑布模型带反馈和回溯">#</a> 改进的瀑布模型：带反馈和回溯</h4><ul><li>后期活动发现有问题后，可返回到前面活动加以解决</li><li>提高了过程模型的灵活性</li><li><mark>不足</mark><ul><li>软件开发处于动荡之中</li><li><strong>需等到所有功能实现后</strong>， 才能得到可运行软件</li></ul></li></ul><h3 id="增量模型incremental-model"><a class="anchor" href="#增量模型incremental-model">#</a> 增量模型 (Incremental Model)</h3><p>需求设计→概要设计→<span class="red"><strong>详细设计→编码实现→集成测试</strong></span>→确认测试</p><p><span class="red"><strong>详细设计→编码实现→集成测试</strong></span> 可以增量（执行 n 次）</p><ul><li>渐进式：增量的实现软件功能</li><li>优点：渐进快速交付，并行开发，提高效率</li><li>局限性：小项目可能不适用；软件需求确定且不 易于变化</li></ul><h3 id="迭代模型iterative-model"><a class="anchor" href="#迭代模型iterative-model">#</a> 迭代模型 (Iterative Model)</h3><p>迭代 n 次：<strong>需求分析→概要设计→详细设计→编码实现→软件测试</strong></p><p>每次迭代完成<ins>部分可确定的软件需求</ins></p><ul><li>每次迭代是一完整过程，体现了小步快跑的开发理念，适合<ins class="red">需求难导出、不易确定且持续变动的软件</ins></li><li>局限性：迭代多少次不确定、管理较为复杂</li></ul><div class="note primary"><p><strong>增量过程模型与迭代过程模型有何区别？</strong></p><p><span class="spoiler bulr" title="你知道得太多了">增量模型（横向扩展）迭代模型（纵向扩展）</span></p></div><details class="info"><summary>软件需求获取是一关键和瓶颈问题</summary><div><ul><li>软件需求非常关键 —— 软件开发的基础、验收的依据</li><li>用户讲不清楚软件需求有哪些、是什么？</li><li>用户与软件工程师对软件需求理解存在偏差（对软件需求描述的<ins>歧义性、二义性、不准确</ins>等造成的）</li></ul></div></details><h3 id="原型模型prototype-model"><a class="anchor" href="#原型模型prototype-model">#</a> 原型模型 (Prototype Model)</h3><p><img data-src="https://img-blog.csdnimg.cn/20200415194559799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hleWk1MzUxMjMw,size_16,color_FFFFFF,t_70#pic_center" alt="原型模型和快速原型模型"></p><ul><li><p>软件原型作为交流载体和媒介 、<strong>支持用户参与到软件开发中</strong>持续、渐进地导出用户要求</p></li><li><p>适合于<strong>需求难导出、不易确定且持续变动</strong>的软件</p></li><li><p>缺点：对于分析人员要求高，既需要懂客户，也需要懂技术，还要懂管理，把握软件开发的约束性条件。</p></li></ul><h3 id="螺旋模型spiral-model"><a class="anchor" href="#螺旋模型spiral-model">#</a> 螺旋模型 (Spiral Model)</h3><p><img data-src="https://th.bing.com/th/id/R.6a4c152c7f77ca8f85a0df50cb3f7822?rik=BA0zoB0goNY76g&amp;riu=http%3a%2f%2fwww.uml.org.cn%2fSoftWareProcess%2fimages%2f20220228101.png&amp;ehk=l1AHyrClx59%2biqUXD2tBy8IcoEwCXMuopWawx2y4Jog%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="螺旋模型(Spiral Model)"></p><div class="note info"><p><strong>软件风险</strong>：使软件开发受到影响和损失、 甚至导致失败的、可能会发生的事件</p></div><ul><li>集成迭代模型和原型模型，<span class="red">引入风险分析，风险驱动的过程模型</span></li><li>每个迭代四个阶段，若干活动</li><li>适合于<strong>需求不明确、开发风险高、开发过程中需求变更大</strong>的软件项目</li><li>不足：管理复杂</li></ul><h3 id="不同软件模型的特点"><a class="anchor" href="#不同软件模型的特点">#</a> 不同软件模型的特点</h3><table><thead><tr><th>模型名称</th><th>指导思想</th><th>关注点</th><th>适合软件</th><th>管理难度</th></tr></thead><tbody><tr><td>瀑布模型</td><td>提供系统性指导</td><td>与软件生命周期相一致</td><td>需求变动不大、较为明确、易可预先定义的应用</td><td>易</td></tr><tr><td>原型模型</td><td>以原型为媒介指导用户的需求导出和确认</td><td>需求获取、导出和确认</td><td>理解需求难以表达清楚、不易导出和获取的应用</td><td>易</td></tr><tr><td>增量模型</td><td>快速交付和并行开发</td><td>软件详细设计、编码和测试的增量式完成</td><td>需求变动不大、较为明确、易可预先定义的应用</td><td>易</td></tr><tr><td>迭代模型</td><td>多次迭代，每次仅针对部分明确软件需求</td><td>分多次迭代来开发软件，每次仅关注部分需求</td><td>需求变动大、难以一次性说清楚的应用</td><td>中等</td></tr><tr><td>螺旋模型</td><td>集成迭代模型和原型模型，引入风险分析</td><td>软件计划制定和实现阶段，软件风险管理</td><td>开发风险大、需求难以确定的应用</td><td>难</td></tr></tbody></table><h2 id="敏捷软件开发方法agile-method"><a class="anchor" href="#敏捷软件开发方法agile-method">#</a> 敏捷软件开发方法 (Agile Method)</h2><p>重视人和交互、重视可运行软件系统、重视客户合作、重视响应用 户需求变化。少写软件文档，以代码为中心，快速响应变化</p><ul><li><p><strong>准则</strong></p><p>快速反馈、简单性假设、逐步修改、提倡更改、优质工作</p></li><li><p><strong>代表方法</strong></p><p>自适应开发、水晶方法、特征驱动开发、SCRUM、极限编程</p></li></ul><h2 id="summary-3"><a class="anchor" href="#summary-3">#</a> Summary</h2><ul><li><p><strong>软件开发需要过程指导</strong></p><p>明确步骤、活动、次序、关系</p></li><li><p><strong>多样化的软件过程模型</strong></p><p>瀑布、增量、迭代、原型、螺旋等</p></li><li><p>选择合适的软件过程模型</p><ul><li>考虑软件项目的特点和要求</li><li>结合软件过程模型的优缺点</li><li>考虑开发团队的经验和水平</li></ul></li></ul><h1 id="第四章-软件需求分析基础"><a class="anchor" href="#第四章-软件需求分析基础">#</a> 第四章 软件需求分析基础</h1><p>软件利益相关方→软件需求→软件开发→软件产品</p><p>软件利益相关方是软件需求的<span class="red"><strong>价值所在</strong></span></p><p>软件需求是软件开发的<span class="red"><strong>开发依据</strong></span>、是软件产品的<span class="red"><strong>验收标准</strong></span></p><h2 id="需求挖掘的来源利益相关方"><a class="anchor" href="#需求挖掘的来源利益相关方">#</a> 需求挖掘的来源：利益相关方</h2><p>利益相关方 (stakeholder)</p><ul><li>从软件系统中受益或与软件系统相关的<ins class="dot">人、组织或者系统</ins></li><li><strong>受益</strong>：使用、获益、盈利</li><li><strong>相关</strong>：发生操作和交互、存在关联性</li></ul><p>软件利益相关方的表现形式</p><ul><li><strong>用户</strong>：最终使用软件的人</li><li><strong>客户</strong>：从中获取利益的组织</li><li><strong>系统</strong>：与待开发系统进行交互的系统</li><li><strong>开发者</strong>：负责开发软件系统的人</li></ul><details class="info"><summary>实例</summary><div><p><strong>空巢老人看护软件的利益相关方</strong></p><ul><li>老人、家属、医生、投资方、机器人</li><li><ins>用户</ins>：<span class="spoiler" title="你知道得太多了">老人、家属、医生</span></li><li><ins>客户</ins>：<span class="spoiler" title="你知道得太多了">投资方</span></li><li><ins>系统</ins>：<span class="spoiler" title="你知道得太多了">机器人</span></li></ul></div></details><h2 id="软件需求的类别"><a class="anchor" href="#软件需求的类别">#</a> 软件需求的类别</h2><ul><li><p>软件<strong>功能性</strong>需求 (Functional)</p><p><strong>能够完成的功能</strong>及在某些场景下<strong>可展现的外部可见行为或效果</strong></p></li><li><p>软件<strong>质量方面</strong>的需求 (Quality)</p><ul><li><strong>外部质量属性</strong>：外部可展现的，<span class="red">用户、客户</span>等会非常关心，如<ins class="dot">运行性能、可靠性、易用性</ins>等</li><li><strong>内部质量属性</strong>：隐藏在内部的，<span class="red">软件开发工程师</span>会非常关心，如<ins class="dot">可扩展性、可维护性、可理解性</ins></li></ul></li><li><p>软件<strong>开发约束性</strong>需求 (Constraint)</p><p><strong>开发成本、交付进度、技术选型、遵循标准</strong>等方面提出的要求</p></li></ul><div class="note primary"><p><strong>非功能需求</strong>：产品需求（可用性、效率、可移植性等）、机构需求、外部需求（道德、法律）</p></div><ul><li><p><ins class="dot">获取软件需求方法</ins></p><p>访谈和会议、调查问卷、现场观摩、分析业务资料、软件原型、群体化方法（集思广益）</p></li></ul><h2 id="面向对象需求分析方法"><a class="anchor" href="#面向对象需求分析方法">#</a> 面向对象需求分析方法</h2><h3 id="需求工程"><a class="anchor" href="#需求工程">#</a> 需求工程</h3><p>通过一系列的<strong>过程、策略、方法学和工具</strong>尽可能获得<strong>准确、一致和完整</strong>的软件需求</p><blockquote><p>抽象、建模、分析</p></blockquote><h3 id="面相对象的4个要点"><a class="anchor" href="#面相对象的4个要点">#</a> 面相对象的 4 个要点</h3><ol><li>认为客观世界是由各种<strong>对象</strong>组成的，任何事物都是对象，复杂的对象可以由比较简单的对象以某种方式组合而成。</li><li>把所有对象都划分成<strong>各种对象类</strong>（类 CLASS），每个对象类都定义了一组数据和一组方法。</li><li>按照子类（派生类）和父类（基类）的<strong>继承</strong>关系，把若干个对象类组成一个层次结构的系统（类等级）。</li><li>对象彼此之间仅能通过传递消息互相联系。</li></ol><blockquote><p>万物皆对象</p><p>高度分工，高度复用，Only 消息传递</p></blockquote><div class="note primary"><p>面向对象 = 对象 + 类 + 继承 + 传递消息</p><p>只有同时使用对象，类，继承，消息的方法才是真正面相对象方法</p><p>对象 + 传递消息 = <span class="spoiler bulr" title="你知道得太多了">基于对象的方法</span> 类 + 继承 =<span class="spoiler bulr" title="你知道得太多了"> 基于类的方法</span></p></div><h4 id="对象object属性attribute方法method"><a class="anchor" href="#对象object属性attribute方法method">#</a> 对象 (Object)，属性（Attribute），方法（Method）</h4><ul><li>对象：对象是具体、有意义的、存在的实体</li><li>属性 (Attribute)：对象的性质，其值定义了对象<strong>状态</strong></li><li>操作 (Operation)：也称方法，对象行为，表示对象提供的<strong>服务</strong></li></ul><h4 id="面向对象的概念-类class与实例instance"><a class="anchor" href="#面向对象的概念-类class与实例instance">#</a> 面向对象的概念 - 类（Class）与实例（Instance）</h4><ul><li>类是对一组具有相同特征对象的抽象</li><li>对象与类的关系<ul><li>对象是类的实例，<ins class="dot">类是创建对象的模板</ins></li><li>类是静态的抽象；对象是动态、可运行的实体</li></ul></li></ul><h4 id="面向对象的概念-消息message"><a class="anchor" href="#面向对象的概念-消息message">#</a> 面向对象的概念 - 消息 (Message)</h4><ul><li><p>消息传递是实现对象间通讯和协作的基本手段</p><p>一个对象向另一个对象发送消息来请求其服务</p></li><li><p>消息描述：接收对象名、操作名和参数: received-obj.msg-name (para.)</p></li><li><p>消息类型</p><ul><li>同步消息：请求者需要<strong>等待响应者的处理结果</strong></li><li>异步消息：请求者发出消息后继续工作，<strong>无需等待</strong></li></ul></li></ul><h3 id="面向对象的核心概念"><a class="anchor" href="#面向对象的核心概念">#</a> 面向对象的核心概念</h3><h4 id="封装encapsulation"><a class="anchor" href="#封装encapsulation">#</a> 封装（Encapsulation）</h4><p>面向对象的程序中把数据和实现操作的代码集中起来放在对象内部。 使用一个对象的时候，只需知道它向外界提供的接口形式，而<ins>无需知道它的数据结构细节和实现操作的算法</ins>。</p><p>具有封装性的条件：</p><ul><li>有一个清晰的边界；</li><li>有明确的接口；</li><li>受保护的内部实现</li></ul><h4 id="继承inheritance"><a class="anchor" href="#继承inheritance">#</a> 继承（Inheritance）</h4><ul><li>表示类与类间的一般与特殊关系</li><li>子 (特殊) 类可共享父 (一般) 类的属性和操作</li><li>借助继承可形成系统的<strong>层次化</strong>类结构</li></ul><p><strong>继承的传递性</strong>：继承具有传递性，如果类 C 继承类 B，类 B 继承类 A，则类 C 继承类 A。</p><p><img data-src="https://www.itbaizhan.com/wiki/imgs/2661477-20220117165638615-1773617277.png" alt="类的继承"></p><div class="note primary"><p><strong>uml: 直线三角空心箭头 指向父类</strong></p></div><h5 id="多态性"><a class="anchor" href="#多态性">#</a> <span class="red"><strong>多态性</strong></span></h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Animal makes a sound"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog barks"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cat meows"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PolymorphismExample</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token class-name">Animal</span> animal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token class-name">Animal</span> animal2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        animal1<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Dog barks</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        animal2<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cat meows</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        </pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">Animal</span> ref<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        ref <span class="token operator">=</span> animal1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        ref<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Dog barks</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        </pre></td></tr><tr><td data-num="32"></td><td><pre>        ref <span class="token operator">=</span> animal2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        ref<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cat meows</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><div class="note info"><p>可以通过父类实例化子类，或者引用子类</p></div><details class="success"><summary>多态性</summary><div><p>多态是面向对象编程的重要特性之一，它允许不同类型的对象对同一消息作出不同的响应。通过父类引用指向子类对象，可以在运行时根据实际的对象类型来决定调用哪个具体的方法实现，增加了程序的灵活性和可扩展性。</p></div></details><details class="primary"><summary>this指针</summary><div><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Animal makes a sound"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callMakeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog barks"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">//    @Override</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">//    public void callMakeSound() &#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">//       System.out.println("In Dog's showThis(), this is a Dog object.");</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">//        // 调用父类的方法，展示不同的 this</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">//        super.showThis();</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">//    &#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><div class="note info"><p>this 指针严格执行本体函数，而非覆盖过后的</p><p>super 严格指向父类，而非覆盖后的</p></div></div></details><p><ins class="dot green"><strong>对象声明</strong>是为对象的<strong>引用</strong>创建一个空间，而<strong>对象生成</strong>则是创建一个类的实例，即为对象分配空间，并将对象空间的地址赋给其引用</ins></p><h5 id="引用"><a class="anchor" href="#引用">#</a> <span class="red"><strong>引用</strong></span></h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PolymorphismExample</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>		<span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  a 是 A 类型的引用， 但对象是 B 类型（这里 B 是 A 的子类）</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span> <span class="token comment">// 将 a 转为 B 的引用</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        b<span class="token punctuation">.</span><span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//fun3 是 B 独自实现的，正确</span></pre></td></tr><tr><td data-num="6"></td><td><pre>       	<span class="token comment">// A a = new A (); //  a 是 A 类型的引用， 但对象是 A 类型（这里 B 是 A 的子类）</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// B b = (B) a; // 将 a 转为 B 的引用</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">//b.fun3 (); //fun3 是 B 独自实现的，错误，对象是 A 没有 B 的方法！！</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>“引用”<strong> 所能够调用的 “方法” 取决于 “引用” 的类型</strong>， 而该 “方法” 如何<strong>具体实现</strong>取决于<span class="red"><strong> &quot;对象&quot; 的类型</strong></span></p><h4 id="覆盖override"><a class="anchor" href="#覆盖override">#</a> 覆盖 (Override)</h4><p>子类<strong>增加或重新定义</strong>所继承的属性或方法，从而用新定义的属性和方法来覆盖所继承的、来自父类中的属性或方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span>｛</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token class-name">String</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> 	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> 		<span class="token keyword">return</span> “<span class="token class-name">Value</span> is<span class="token operator">:</span>” <span class="token operator">+</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> 	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>｝</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> 	<span class="token class-name">String</span> address<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> 	<span class="token keyword">public</span> <span class="token class-name">String</span> getValue <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> 		<span class="token keyword">return</span> “<span class="token class-name">Value</span> is<span class="token operator">:</span>” <span class="token operator">+</span> address<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 子类 B 重新定义所继承的方法 getValue</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="重载overload"><a class="anchor" href="#重载overload">#</a> 重载 (Overload)</h4><p>一个类中有多个同名操作，但它们在操作数或操作数类型上有区别，系统根据实参引用不同方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> 	<span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> 	<span class="token class-name">String</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> agePara<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> 		age <span class="token operator">=</span> agePara<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> 	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">String</span> namePara<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>		name <span class="token operator">=</span> namePara<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="初步软件需求"><a class="anchor" href="#初步软件需求">#</a> 初步软件需求</h3><h4 id="自然语言描述"><a class="anchor" href="#自然语言描述">#</a> 自然语言描述</h4><p>自然语言是最为常用的需求描述手段；描述软件的功能性需求、质量需求和开发约束需求等</p><ul><li>不具体</li><li>不准确</li><li>有二义</li><li>不直观</li></ul><h4 id="软件原型描述"><a class="anchor" href="#软件原型描述">#</a> 软件原型描述</h4><ul><li>优势<ul><li>直观、可展示和可操作</li></ul></li><li>不足<ul><li>主要以操作界面的形式展示软件需求的 梗概，主要是软件与用户之间的输入和 输出，业务的大致流程，<strong>无法描述软件需求的具体细节</strong></li></ul></li></ul><h4 id="uml-建模语言描述"><a class="anchor" href="#uml-建模语言描述">#</a> UML 建模语言描述</h4><ul><li>Unified (统一)：提取不同方法中最好建模技术，如 OMT (James Rumbaugh)，Booch method (Grady Booch ) 和 OOSE (Ivar Jacobson)；采用统一、标准化的表示方式，支持不同 人员之间的交流；</li><li>Modeling (建模)：基于面向对象的概念和抽象，对现实系统和软件系统进行可视化建模； 、</li><li>Language (语言)：提供图形化的图符，用来表示软件系统的一种语言。</li></ul><table><thead><tr><th>视点</th><th>图 (diagram)</th><th>说明</th></tr></thead><tbody><tr><td>结构</td><td>包图 (package diagram)</td><td>从包层面描述系统的静态结构</td></tr><tr><td></td><td>类图 (class diagram)</td><td>从类层面描述系统的静态结构</td></tr><tr><td></td><td>对象图 (object diagram)</td><td>从对象层面描述系统的静态结构</td></tr><tr><td></td><td>构件图 (component diagram)</td><td>描述系统中构件及其依赖关系</td></tr><tr><td></td><td>状态图 (statechart diagram)</td><td>描述状态的变迁</td></tr><tr><td>行为</td><td>活动图 (activity diagram)</td><td>描述系统活动的实现</td></tr><tr><td></td><td>通信图 (communication diagram)</td><td>描述对象间的消息传递与协作</td></tr><tr><td></td><td>顺序图 (sequence diagram)</td><td>描述对象间的消息传递与协作</td></tr><tr><td>部署</td><td>部署图 (deployment diagram)</td><td>描述系统在工作在物理运行环境中的部署情况</td></tr><tr><td>用例图</td><td>用例图 (use case diagram)</td><td>从外部用户角度描述系统功能</td></tr></tbody></table><h4 id="ruprational-unified-process"><a class="anchor" href="#ruprational-unified-process">#</a> RUP（Rational Unified Process）</h4><ul><li><strong>初始阶段</strong>主要任务是理解和分析 需求，生成用例模型框架；</li><li><strong>精化阶段</strong>是完成高优先级的用例 开发，完善用例模型；</li><li><strong>构建阶段</strong>真是多次迭代，完成不 同优先级用例开发；</li><li><strong>交付阶段</strong>则是进行各种功能，性 能测试，进行产品化部署，完成 系统开发。</li></ul><h3 id="用例图描述"><a class="anchor" href="#用例图描述">#</a> 用例图描述</h3><p>用例：文本形式的情节描述，用以说明某参与者使用系统以实现某一特定目标的情形，描述的是外部行为者所理解的系统功能。</p><p>用例建模：用于描述一个系统应该做什么（功能需求），用用例图来描述 (可能有多幅)</p><p>用例图：把系统看做黑盒子，给出了用户所感受到的系统行为，<ins>但不描述系统如何实现该功能</ins>，驱动了需求分析之后各阶段的开发工作。</p><h4 id="用例建模"><a class="anchor" href="#用例建模">#</a> 用例建模</h4><p>在 UML 中，用例图的主要元素是系统、用例、行为者以及用例之间的关系：</p><ul><li>系统边界、用例</li><li>执行者 (参与者)：可能使用这些用例的人或外部系统，参与者与用例连接表示参与者使用了该用例</li><li>模型元素间关系：<ins>关联、扩展、包含、泛化</ins>等</li></ul><h5 id="系统"><a class="anchor" href="#系统">#</a> 系统</h5><p>代表系统的方框的边线表示系统的边界，用于划定系统的功能范围、定义了系统所具有的功能</p><p>描述该系统功能的用例置于方框内，代表外部实体的行为都置于方框外</p><h5 id="执行者actor"><a class="anchor" href="#执行者actor">#</a> 执行者 (Actor)</h5><p>行为者是指与系统交互的人或其他系统，它代表外部实体</p><p><ins>在用例图中，<strong>连接行为者和用例的直线</strong>，表示两者之间交换信息，称为通信联系</ins></p><p>单个行为者可与多个用例联系，一个用例也可与多个行为者联系</p><h5 id="用例use-case"><a class="anchor" href="#用例use-case">#</a> 用例 (Use Case)</h5><p>用例是一个类，它代表一类功能而不是使用该功能的某个具体实例</p><ul><li>用例代表某些用户可见的功能，实现一个具体的用户目标；</li><li>用例总是被行为者启动的，并向行为者提供可识别的值；</li><li>用例必须是完整的</li></ul><blockquote><p>通常把用例的实例称为脚本</p></blockquote><h5 id="用例间的关系"><a class="anchor" href="#用例间的关系">#</a> 用例间的关系</h5><ul><li><p>扩展关系</p><p>向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关系就是扩展关系 。后者继承前者的一些行为，通常把后者称为扩展用例，用例之间的扩展关系图示为带构造型 &lt;&lt;extend&gt;&gt; 的关系 <code>--&gt;</code></p></li><li><p>包含关系</p><p>当一个用例包含另一个用例的全部步骤时，这两个用例之间就构成了包含关系，用带构造型 &lt;&lt;include&gt;&gt; 的关系 <code>--&gt;</code></p></li><li><p>泛化关系</p><p>一个一般用况与一个更特殊的用况之间的关系，特殊用况可继承一般用况的特征，用 <code>—▷</code> 表示</p></li></ul><p><img data-src="https://image.woshipm.com/wp-files/2021/06/ogjiS2n2L5tXMxsyBaLW.png" alt="用例图"></p><div class="note info"><p><strong>步骤</strong>：定义系统 (总体范围)；确定参与者；确定用例；描述用例；定义用例间的关系；确认 模型。</p></div><h2 id="需求分析过程"><a class="anchor" href="#需求分析过程">#</a> 需求分析过程</h2><ol><li><p>初步软件需求：分析和确定软件需求优先级，得到软件需求优先级列表；</p></li><li><p>软件需求优先级列表：分析和建立软件需求模型；</p></li><li><p>软件需求模型：文档化软件需求，形成软件需求文档；</p></li><li><p>软件需求文档：对软件需求进行确认和验证。</p></li><li><p>得到确认和验证后的软件需求模型和文档。</p><blockquote><p>整个过程不断迭代。</p></blockquote></li></ol><p><strong>需求工程的输出软件需求制品</strong></p><p><strong>一、软件原型</strong><br>以可运行软件的形式，直观地展示软件的业务工作流程、操作界面、用户的输入和输出等方面的功能性需求信息。</p><p><strong>二、软件需求模型</strong><br>以可视化的图形方式，从多个不同视角直观地描述软件的功能性需求，包括用例模型、用例的交互模型、分析类模型、状态模型等。</p><p><strong>三、<span class="red">软件需求文档</span></strong><br><ins>以图文并茂的方式，结合需求模型以及需求的自然语言描述，详尽刻画软件需求，包括功能性和非功能性软件需求以及软件需求的优先级列表等。</ins></p><h2 id="summary-4"><a class="anchor" href="#summary-4">#</a> Summary</h2><ul><li><strong>软件需求</strong>来自软件利益相关者，表现形式多样且多变易变。</li><li><strong>需求工程</strong>是用工程手段支持需求的获取、分析、建模和文档化。</li><li><strong>面向对象需求分析方法学</strong>的基本思想是系统中的对象及其功能、行为和协作，基本概念有对象、类、消息传递等，建模语言为 UML 及不同视角的图。</li><li><strong>分析软件需求</strong>的步骤有<ins>分析确立需求优先级、建立需求模型、撰写需求规格说明书、评审需求文档</ins>。<span class="label success">🎖️</span></li></ul><h1 id="第五章-软件分析"><a class="anchor" href="#第五章-软件分析">#</a> 第五章 软件分析</h1><p>顺序图、类图、状态图</p><p>分析软件需求过程</p><p>软件需求文档</p><h2 id="软件分析的任务"><a class="anchor" href="#软件分析的任务">#</a> 软件分析的任务</h2><p>基于初步软件需求，进一步精化和分析软件需求，确定软件需求优先级，建立软件需求模型，发现和解决软件需求缺陷，形成高质量的软件需求模型和软件需求规格说明书</p><h3 id="类图"><a class="anchor" href="#类图">#</a> 类图</h3><p>类名 、属性 、操作</p><p><img data-src="https://www.iyunying.org/wp-content/uploads/2017/05/45cef248917ef234ae43602b1b86c6a6.png" alt="UML建模之类图"></p><p><strong>结点</strong>：表示系统中的 类（或接口）及其属 性和操作</p><p><strong>边</strong>：类之间的关系</p><div class="note primary"><p>在 UML 类图中，常见的有以下几种关系: <ins>泛化（Generalization）, 实现 （Realization），关联（Association)，聚合（Aggregation），组合 (Composition)，依赖 (Dependency)。</ins></p><p><strong>各种关系的强弱顺序</strong>： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p></div><p>在 UML（Unified Modeling Language）中，类之间有多种关系来表示不同的关联方式。</p><ol><li><strong>关联 (Association)</strong>：<ul><li>表示两个类之间的基本关系，通常是某个类包含对另一个类的引用。</li><li>关联可以是单向或双向的，表示对象之间的通信。</li><li><strong>符号</strong>：<ins>实线</ins>，可能有箭头（单向关联）或没有箭头（双向关联）。</li></ul></li></ol><ul><li><code>—</code></li></ul><ol start="2"><li><strong>聚合 (Aggregation)</strong>：<ul><li>表示 “整体 - 部分” 关系，<strong>但部分可以独立于整体存在</strong>。</li><li>例如，班级和学生之间的关系，学生属于班级，但学生可以独立存在。</li><li><strong>符号</strong>：带空心菱形的实线，菱形指向整体的一端。</li></ul></li></ol><ul><li><code>-◇</code></li></ul><ol start="3"><li><p><strong>组合 (Composition)</strong>：</p><ul><li>表示 “整体 - 部分” 关系，<strong>部分不能独立于整体存在</strong>。更强的一种整体与部分间的拥有关系，整体负责部 分的创建和删除</li><li>例如，房间和墙壁之间的关系，房间消失时，墙壁也随之消失。</li><li><strong>符号</strong>：带实心菱形的实线，菱形<ins>指向整体</ins>的一端。</li></ul></li></ol><ul><li><code>-◆</code></li></ul><ol start="4"><li><p><strong>继承 / 泛化 (Generalization)</strong>：</p><ul><li>表示类之间的 “is-a” 关系，子类继承父类的属性和方法。</li><li>例如，动物类和狗类之间的关系，狗是动物的一种。</li><li><strong>符号</strong>：空心三角形箭头<ins>指向父类</ins>。</li></ul></li></ol><ul><li><code>-▷</code></li></ul><ol start="5"><li><p><strong>实现 (Realization)</strong>：</p><ul><li>表示<strong>类与接口之间的关系，类实现接口的行为</strong>。</li><li>例如，飞行接口和鸟类之间的关系，鸟实现了飞行的接口。</li><li><strong>符号</strong>：带空心三角形的虚线箭头<ins>指向接口</ins>。</li></ul></li></ol><ul><li><code>- - - -▷</code></li></ul><ol start="6"><li><p><strong>依赖 (Dependency)</strong>：</p><ul><li>两个元素之间的依赖关系。</li><li>例如，方法中使用的参数类型或局部变量类型。</li><li><strong>符号</strong>：虚线箭头，箭头指向<ins>被依赖的类 / 被使用的类</ins>。</li></ul></li></ol><ul><li><code>---&gt;</code></li></ul><div class="note info"><p><ins>注意数字关系</ins></p></div><p><img data-src="https://th.bing.com/th/id/R.e3ee50211906b275e39bce30dfd4f098?rik=p%2fP22fLso6wNQw&amp;riu=http%3a%2f%2fstatic.codingwhy.com%2fcms%2f20160612%2f1465734116852034956.jpg&amp;ehk=siVFWC1mQO6OnCB707A2tY95YUc5VhfKAd0KAOkHnp4%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="UML类图"></p><h3 id="状态图"><a class="anchor" href="#状态图">#</a> 状态图</h3><p><strong>状态图</strong>：是一种由状态、变迁、事件和活动组成的状态机，用来描述类的对象所有可能的状态以及时间发生时状态的转移条件。</p><p><strong>状态变量</strong>：是状态机图所显示的类的属性，也可以是临时变量</p><p><strong>活动</strong>：列出了处于该状态时要执行的事件和动</p><p>UML 状态图（State Diagram）用于描述对象在生命周期中的状态变化，尤其是在响应事件或条件时的变化。它适合用于模型化具有明确状态转换的复杂对象行为，通常用于描述单个对象的状态机。</p><h4 id="uml状态图的基本组成要素"><a class="anchor" href="#uml状态图的基本组成要素">#</a> UML 状态图的基本组成要素</h4><ol><li><p><strong>状态 (State)</strong>：</p><ul><li><strong>表示对象在生命周期中的某个特定状态或条件</strong>。状态用带标签的<strong>矩形框</strong>表示。</li><li>每个状态可以包含进入活动 (entry action)、退出活动 (exit action)、内部活动 (internal activity)、以及子状态。</li></ul></li><li><p><strong>初始状态 (Initial State)</strong>：</p><ul><li>表示对象在<strong>生命周期中的起始状态</strong>。用一个<strong>填充的黑色圆圈</strong>表示。</li><li>初始状态<ins>指向第一个有效的状态</ins>。</li></ul></li><li><p><strong>终止状态 (Final State)</strong>：</p><ul><li>表示<strong>对象生命周期的结束</strong>。用一个黑色圆圈，外部包裹一个空心圆圈来表示。</li><li>当状态机到达终止状态时，对象的生命周期就结束了。</li></ul></li><li><p><strong>转换 (Transition)</strong>：</p><ul><li>表示状态之间的转换关系，即对象在满足某些条件或事件触发时从一个状态迁移到另一个状态。</li><li>转换用带箭头的线表示，并可标注触发事件、条件守护 (guard condition)、以及动作 (action)。</li><li>例如： <code>事件名[条件] / 动作</code> 。</li></ul></li><li><p><strong>事件 (Event)</strong>：</p><ul><li>是状态之间发生转换的触发因素，可能是用户输入、方法调用或系统触发。</li><li>事件通常写在转换箭头旁边。</li></ul></li><li><p><strong>动作 (Action)</strong>：</p><ul><li>是在状态转换过程中执行的活动。可以在转换箭头上标注执行的动作。</li></ul></li><li><p><strong>子状态 (Substate)</strong>：</p><ul><li>状态图支持嵌套状态，称为复合状态 (Composite State)。复合状态中包含的子状态可以是顺序 (Sequential) 的，也可以是并行 (Concurrent) 的。</li></ul></li></ol><blockquote><p>复杂状态机行为的系统时非常有用，比如电梯控制系统、交易处理系统等。</p></blockquote><p><img data-src="https://pic3.zhimg.com/v2-a1bd2ebdc21060b28c867a04d55f802a_1440w.jpg?source=172ae18b" alt="UML状态图详解 - 知乎"></p><h3 id="顺序图"><a class="anchor" href="#顺序图">#</a> 顺序图</h3><p>交互图的一种，描述了对象之间消息发送的先后顺序，<strong>强调时间顺序</strong>。序列图的主要用途是把用例表达的需求，转化为进一步、更加正式层次的精细表达。用例常常被细化为一个或者更多的序列图。同时序列图更有效地描述如何分配各个类的职责以及各类具有相应职责的原因。</p><ul><li>描述对象间的消息交互序列<ul><li><strong>纵向</strong>：时间轴，对象及其<ins>生命线</ins> (虚线)，活跃期 (长条矩形)</li><li><strong>横向</strong>：对象间的消息传递，用一个矩形框表示，框内标有对象名。名称可带下划线，意味 着序列图中的生命线代表<ins>一个类的特定实例</ins>。</li><li><ins>对象间的通信用对象生命线之间的水平消息线来表示</ins>，消息箭头的形状表明消息的类型。 箭头以时间顺序在图中从上到下排列。</li></ul></li></ul><h2 id="软件分析过程"><a class="anchor" href="#软件分析过程">#</a> 软件分析过程</h2><h3 id="面向对象分析"><a class="anchor" href="#面向对象分析">#</a> 面向对象分析</h3><p>面向对象分析，就是<strong>抽取和整理用户需求</strong>，并<strong>建立问题域精确模型的过程</strong>。</p><p>面向对象建模得到的模型包含对象的<strong>三个要素（子模型）</strong>：静态结构（对象模型）， 交互次序（动态模型），和数据变换（功能模型）。</p><ul><li><p>对象模型</p><p>定义做事情的实体 —— 静态<span class="red"><strong>数据结构</strong></span></p><p>用例图</p></li><li><p>动态模型</p><p>规定什么时候做 ——<span class="red"><strong> 执行操作</strong></span></p><p>状态图、序列图、活动图</p></li><li><p>功能模型</p><p>系统应该做什么 ——<span class="red"><strong> 数值变化</strong></span></p><p>用例图</p></li></ul><div class="note info"><p><strong>用面向对象方法开发软件，在任何情况下，对象模型始终都是<ins>最重要、最基本、最核心</ins>的</strong></p></div><h3 id="构建对象模型"><a class="anchor" href="#构建对象模型">#</a> 构建对象模型</h3><p>复杂问题（大型系统）的对象模型由下述五个层次组成：<span class="red"><strong>主题层（范畴层）、结构层， 类 &amp; 对象层，属性层和服务层。</strong></span></p><ul><li>找出类 -&amp;- 对象；定义属性；定义服务；识别结构；识别主题；反复修改。</li></ul><details class="info"><summary>定义结构</summary><div><p><strong>对象（以及它们的类）与外部的关系有如下四种：</strong></p><p>（1）一般 - 特殊关系（<ins>继承关系</ins>）：即对象之间的分类关系，用一般 - 特殊结构表示；</p><p>（2）整体 - 部分关系：即对象之间的<ins>组成关系</ins>，用整体 - 部分结构表示；</p><p>（3）静态连接关系：即通过对象属性所反映出来的联系，用<ins>实例连接</ins>表 示；</p><p>（4）动态连接关系：即对象行为之间的依赖关系，用<ins>消息连接</ins>表示。</p></div></details><h3 id="动态模型"><a class="anchor" href="#动态模型">#</a> 动态模型</h3><p>每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起来（交互图），从而构成系统的动态模型。</p><p><strong>动态模型</strong>是基于事件共享而互相关联的一组状态图的集合。</p><p>行为分类</p><ol><li><p>系统行为 — 如<ins>创建、删除、复制、转存</ins>。</p></li><li><p>对象自身的简单行为 —— 如读、写属性值。</p></li><li><p>对象自身的复杂行为 —— 如计算或监控。</p></li></ol><h3 id="功能模型"><a class="anchor" href="#功能模型">#</a> 功能模型</h3><p>功能模型表示变化的系统的 “功能” 性质，它指明了系统应该 “做什么”，因此更直接地反映了用户对目标系统的需求。</p><p>功能模型由一组数据流图组成。一般说来，与对象模型和动态模型比较起来，数据流图并没有增加新的信息，但是建立功能模型有助于软件开发人员更深入地理解问题域，改进和完善自己的设计。</p><h3 id="小结"><a class="anchor" href="#小结">#</a> 小结</h3><p>三个模型从三个不同的角度对所要开发的系统进行了描述，三个模型<strong>相互补充、相互配合，使得开发人员能够更全面的认识系统。</strong></p><ul><li><p>对象模型：以对象、属性、关系和操作形式描述系统结构；</p></li><li><p>动态模型：描述系统的内部行为；</p></li><li><p>功能模型：从户用的观点描述系统功能。</p></li></ul><p><ins class="dot">功能模型指出发生了什么，动态模型确定什么时候发生，而对象模型确定发生的客体。</ins></p><h2 id="summary-5"><a class="anchor" href="#summary-5">#</a> Summary</h2><ul><li>分析软件是要精化和深化软件需求<ul><li>基于初步软件需求，循序渐进</li><li>确保软件需求的<ins>完整性、一致性和准确性</ins></li></ul></li><li>UML 提供的、用于描述<ins>软件需求</ins>的图<ul><li>用例图、交互图、分析类图、状态图</li></ul></li><li>软件需求分析的难点<ul><li>软件需求不易捕获</li><li>软件变化是无可避免</li></ul></li></ul><div class="note primary"><p>需求变更永无停止！！！</p></div><h1 id="第六章-软件设计基础"><a class="anchor" href="#第六章-软件设计基础">#</a> 第六章 软件设计基础</h1><h2 id="软件设计的质量要求"><a class="anchor" href="#软件设计的质量要求">#</a> 软件设计的质量要求</h2><p>软件设计是一个创作的过程</p><p>一个软件需求会有多种软件设计方案</p><ul><li>高可靠性</li><li>高效率</li><li>高可维护性</li><li>高可理解性</li></ul><h2 id="软件设计基本原则"><a class="anchor" href="#软件设计基本原则">#</a> 软件设计基本原则</h2><details class="primary"><summary>总则</summary><div><ol><li>抽象与逐步求精</li><li>模块化，高内聚度、低耦合度</li><li>信息隐藏</li><li>多视点和关注点分离</li><li>软件重用</li><li>迭代设计</li><li>可追踪性</li></ol></div></details><h3 id="抽象原则"><a class="anchor" href="#抽象原则">#</a> 抽象原则</h3><p>在认识事物、分析和解决问题的过程中，忽略那些与当前研究目标不相关的部分，以便将注意力集中于与当前目标相关的方面</p><p>不要过早地考虑细节</p><p><ins>抽象是管理和控制复杂性的基本策略</ins></p><div class="note info"><p><strong>体系结构设计抽象</strong>→<strong>类设计抽象</strong>→<strong>算法设计抽象</strong></p><p><code>结构性 全局性 关键性</code> → <code>过程性 局部性 细节性</code></p></div><h3 id="模块化-高内聚度和低耦合度原则"><a class="anchor" href="#模块化-高内聚度和低耦合度原则">#</a> 模块化、高内聚度和低耦合度原则</h3><p>将软件系统的整体结构分解为一组相关模块</p><ul><li>每个模块实现单一的功能</li><li>模块内部强内聚、模块之间低耦合</li></ul><h3 id="例题"><a class="anchor" href="#例题">#</a> 例题</h3><ol><li class="quiz"><p>模块独立性是软件模块化所提出的要求，衡量模块独立性的度量标准是<span class="gap"></span>。</p><ul class="options"><li>抽象和信息隐蔽</li><li>局部化和封装化</li><li class="correct">内聚性和耦合性</li><li>激活机制和控制方法</li></ul></li><li class="quiz"><p>对软件的过分分解，必然导致<span class="gap"></span>.</p><ul class="options"><li>模块的独立性变差</li><li>接口的复杂程度增加</li><li>软件开发的总工作量增加</li><li class="correct">以上都正确</li></ul></li><li class="quiz"><p>模块中所有成分引用共同的数据，该模块的内聚度是<span class="gap"></span>.</p><ul class="options"><li>逻辑性</li><li>瞬时性</li><li>功能性</li><li class="correct">通信性</li></ul></li><li class="quiz"><p>一个模块把开关量作为参数传送给另一模块，这两个模块之间的耦合是<span class="gap"></span>.</p><ul class="options"><li>外部耦合</li><li>数据耦合</li><li class="correct">控制耦合</li><li>内容耦合</li></ul></li></ol><h3 id="信息隐藏原则"><a class="anchor" href="#信息隐藏原则">#</a> 信息隐藏原则</h3><p>模块应该设计得使其所含的信息对<strong>那些不需要这些信息的模块不可访问</strong>；模块间仅仅交换那些为完成系统功能所必需交换的信息</p><ul><li>模块的独立性更好</li><li>支持模块的并行开发（设计和编码）</li><li>便于测试和维护，减少错误向外传播</li><li>便于增加新的功能</li></ul><div class="note info"><p><strong>模块只提供对外接口，不 提供内部实现细节</strong></p></div><h3 id="关注点分离原则"><a class="anchor" href="#关注点分离原则">#</a> 关注点分离原则</h3><p>设计师将若干性质不同的关注点分离开来，以便在适当的时间处理不同的关注点，随后将这些关注点整合起来，形成局部或者全局性的设计结果</p><p><ins>防止 “胡子眉毛一把抓”</ins></p><h3 id="软件重用原则"><a class="anchor" href="#软件重用原则">#</a> 软件重用原则</h3><p><span class="red"><strong>尽可能地重用已有的软件资产来实现软件系统的功能，同时要确保所开发的软件系统易于为其他软件系统所重用</strong></span></p><p>支持软件重用的技术手段</p><ul><li><ins>封装、接口、继承、多态</ins>等</li></ul><p>软件重用的对象</p><ul><li>过程和函数、类、软构件、开源软件</li><li>软件设计模式、软件开发知识</li></ul><h3 id="软件设计的其他原则"><a class="anchor" href="#软件设计的其他原则">#</a> 软件设计的其他原则</h3><details class="primary"><summary>Others</summary><div><ul><li>设计可追溯到分析模型</li><li>经常关注待建系统的架构</li><li>数据设计和功能设计同样重要</li><li>必须设计接口</li><li>用户界面设计必须符合最终用户要求</li><li>设计表述要尽可能易于理解</li><li>设计应该迭代进行</li></ul></div></details><h1 id="第七章-面向对象的软件设计"><a class="anchor" href="#第七章-面向对象的软件设计">#</a> 第七章 面向对象的软件设计</h1><h2 id="软件体系结构设计"><a class="anchor" href="#软件体系结构设计">#</a> 软件体系结构设计</h2><p>常用软件体系结构风格</p><h3 id="分层体系结构风格"><a class="anchor" href="#分层体系结构风格">#</a> 分层体系结构风格</h3><p>界面，业务，服务</p><p>低层向上层提供服务，上层向下层请求服务 —— 交互与约束</p><p><ins>合理地设计抽象层次和组织软构件是关键</ins></p><h3 id="管道与过滤器风格"><a class="anchor" href="#管道与过滤器风格">#</a> 管道与过滤器风格</h3><ul><li><p>构件</p><p>将软件功能实现为一系列处理步骤，每个步骤封装在一个过滤器构件中</p></li><li><p>连接子</p><p>相邻过滤器间以管道连接，一个过滤器的输出数据借助管道流向后续过滤器，作为其输入数据</p></li><li><p>数据</p><p>软件系统的输入由<strong>数据源</strong>（data source）提供</p><p>软件最终输出由源自某个过滤器的管道流向<strong>数据汇</strong>（data sink）</p><p>典型数据源和数据汇包括数据库、文件、其他软件系统、物理设备等</p></li></ul><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>源代码<span class="token arrow operator">--></span>A<span class="token text string">[词法分析]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>A<span class="token arrow operator">--></span>B<span class="token text string">[语法分析]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>B<span class="token arrow operator">--></span>C<span class="token text string">[生成中间码]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>C<span class="token arrow operator">--></span>D<span class="token text string">[代码优化]</span><span class="token arrow operator">--></span>可执行代码<span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>自然地解决<ins>具有数据流特征</ins>的软件需求</li><li>可独立地更新、升级过滤器来实现软件系统的扩展和进化</li></ul><h3 id="黑板风格"><a class="anchor" href="#黑板风格">#</a> 黑板风格</h3><p>将软件系统划分为黑板、知识源和控制器三类构件</p><ul><li>黑板：负责保存问题求解过程中的状态数据，并提供这些数据的读写服务</li><li>知识源：负责根据黑板中存储的问题求解状态评价其自身的可应用性，进行部分问题求解工作，并将此工作的结果数据写入黑板</li><li>控制器：负责监视黑板中不断更新的状态数据，安排（多个）知识源的活动。</li></ul><h4 id="黑板风格的约束"><a class="anchor" href="#黑板风格的约束">#</a> 黑板风格的约束</h4><ul><li><strong>控制构件</strong>通过观察黑板中的状态数据来决定哪些知识源对后续的问题求解可能有所贡献，然后<strong>调用这些知识源</strong>的评价功能以选取参与下一步求解活动的知识源</li><li>被选中的知识源基于黑板中的状态数据<strong>将问题求解工作向前推进</strong>，并根据结果<strong>更新</strong>黑板中的状态数据</li><li>控制构件不断重复上述控制过程，及至问题求解获得满意的结果</li></ul><blockquote><p>案例：智慧树、Notion</p></blockquote><h4 id="黑板风格的特点"><a class="anchor" href="#黑板风格的特点">#</a> 黑板风格的特点</h4><details class="primary"><summary>优点</summary><div><ol><li>可<ins>灵活升级</ins>和更换知识源和控制构件</li><li>知识源的<ins>独立性和可重用性</ins>好。知识源之间没有交互。</li><li>软件系统具有较好的<ins>容错性和健壮性</ins>。知识源的问题求解动作是探索性的， 允许失败和纠错。</li></ol></div></details><details class="info"><summary>缺陷</summary><div><ol><li>为了共享数据，各子系统必须有一致的数据视图，不可避免地会影响了整个系统的<strong>性能</strong>。</li><li>子系统的改变，使产生的<strong>数据结构也可能发生改变</strong>。</li><li>统一的数据库结构 (备份、安全、访问控制和恢复的策), 将影响子系统的<strong>效率</strong>。</li></ol></div></details><h3 id="mvc风格"><a class="anchor" href="#mvc风格">#</a> MVC 风格</h3><p>模型构件</p><ul><li>负责存储业务数据并提供业务逻辑处理功能</li></ul><p>视图构件</p><ul><li>负责向用户呈现模型中的数据</li></ul><p>控制器</p><ul><li>在接获模型的业务逻辑处理结果后，负责选择适当的视图作为软件系统对用户的界面动作的响应</li></ul><p><img data-src="https://www.runoob.com/wp-content/uploads/2014/08/1200px-ModelViewControllerDiagram2.svg_.png" alt="img"></p><h4 id="mvc风格约束"><a class="anchor" href="#mvc风格约束">#</a> MVC 风格约束</h4><p>创建视图，视图对象从模型中<strong>获取数据</strong>并呈现用户界面</p><p>控制器将用户界面事件转换为<ins>业务逻辑处理功能的调用</ins></p><p>模型进行业务逻辑处理，将处理结果<strong>回送给控制器</strong>，必要时还需将业务数据变化事件<strong>通知给所有视图</strong></p><h3 id="soa风格"><a class="anchor" href="#soa风格">#</a> SOA 风格</h3><p>将服务提供方和服务请求方独立开来，因而支持服务间的<span class="red"><strong>松耦合定义</strong></span></p><p>允许任何一个服务在运行过程中<strong>所扮演角色的动态调整</strong>， 支持<strong>服务集合</strong>在运行过程中的<strong>动态变化</strong>，因而具有非常强的<strong>灵活性</strong></p><p>提供了诸如 <code>UDDI、SOAP、WSDL</code> 等协议来支持服务的注册、描述和绑定等，因而可有效支持<strong>异构服务间的交互</strong></p><p><code>服务请求方→服务注册中心：查询服务。服务请求方→服务提供方：访问获得服务。服务提供方→服务注册中心：注册和发布服务</code></p><h3 id="消息总线风格"><a class="anchor" href="#消息总线风格">#</a> 消息总线风格</h3><p>包含了一组软构件和一条称为 “消息总线” 的连接件来连接各个软构件</p><ul><li><strong>消息总线</strong>成为软构件之间的通信桥梁，实现各个软构件之间的消息发送、接收、转发、处理等功能</li><li><strong>每一个软构件通过接入总线</strong>，实现消息的发送和接收功能</li></ul><details class="info"><summary>软件总线</summary><div><p>“软件总线 (Software Bus)” 的中间件 (Middleware) 即对象请求代理 (Object Request Broker，简称 ORB) . <ins>分布式对象结构具有很好的开放性和透明性</ins>，<ins>用户可以非常方便地在总线上添加、更新或删除组件对象</ins>。</p><p>流行的 ORB 技术标准有两种： <code>CORBA(Common Object Request Broker Architecture)</code> , <code>DCOM(Distributed Component Object Model)</code> .</p><p>对象 (Object)”—— 提供服务的系统组件 (System Component)。<ins>每个对象在逻辑上是平等的</ins>，它们可以互相为对方提供所需的服务。<ins>提供服务的对象就是服务器，而提出服务请求的对象就是客户</ins>。</p></div></details><h2 id="软件详细设计"><a class="anchor" href="#软件详细设计">#</a> 软件详细设计</h2><p>详细设计是高层设计和底层实现间的桥梁</p><blockquote><p>高层软件体系结构设计需要通过软件详细设计落实和细化；</p><p>软件的实现需要软件详细设计的辅助和支持。</p><p>所以说软件详细设计是高层软件体系结构设计和软件实现的 <code>桥梁</code> 。</p></blockquote><h3 id="详细设计的工具"><a class="anchor" href="#详细设计的工具">#</a> 详细设计的工具</h3><p>详细设计阶段的任务是<strong>开发一个可以直接转换为程序的<ins>软件表示</ins></strong>，即对系统中每个模块的内部过程进行设计和描述。</p><p>常用的描述方法工具</p><ol><li>流程图</li><li>结构化流程图（N-S 图）</li><li>PAD 图 — 问题分析图</li><li>PDL 语言</li></ol><h4 id="结构化流程图n-s图"><a class="anchor" href="#结构化流程图n-s图">#</a> 结构化流程图（N-S 图）</h4><p>由顺序、选择、循环三种基本结构组成。</p><p><img data-src="https://ts1.cn.mm.bing.net/th/id/R-C.1beccce5c532de1a814f6b267f3fd6b8?rik=6R5eubmHnLWIug&amp;riu=http%3a%2f%2fpic.baike.soso.com%2fp%2f20130713%2f20130713213723-1050754207.jpg&amp;ehk=ab4TDWaRH%2fOu9tVHFc3a%2b42KpHt7qyHoliY%2fXDm4HaE%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="ns流程图 - 搜狗百科"></p><p>例子</p><p><img data-src="https://ts1.cn.mm.bing.net/th/id/R-C.9f9d60e0ad05def325aad0874750c880?rik=asVW9MaHuSA7EQ&amp;riu=http%3a%2f%2fmicro.ustc.edu.cn%2fFortran%2fZJDing%2fSec2-1.files%2fimage037.gif&amp;ehk=FroERhHvUZgzNoFWLcgL8MG1IbJRU9eF6loYDXMyi0U%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="算法和流程图_流程图计算框算法-CSDN博客"></p><h4 id="pad图"><a class="anchor" href="#pad图">#</a> PAD 图</h4><p><img data-src="https://p1.ssl.qhmsg.com/t01818da679e667bae1.jpg" alt="pad图_360百科"></p><p>例子</p><p><img data-src="https://img.wendangwang.com/pic/509410d19a3711a049ad3ba7/6-810-jpg_6-1080-0-0-1080.jpg" alt="新浪微博数据流图及er图和pad图_word文档在线阅读与下载_文档网"></p><h3 id="设计模式类型"><a class="anchor" href="#设计模式类型">#</a> 设计模式类型</h3><p>23 种设计模式可以分为三大类：<strong>创建型模式（Creational Patterns）</strong>、<strong>结构型模式（Structural Patterns）</strong>、<strong>行为型模式（Behavioral Patterns）</strong></p><p>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程。</p><p>结构型模式：把类或对象结合在一起形成一个更大的结构。</p><p>行为型模式：类和对象如何交互，及划分责任和算法</p><h4 id="简单工厂模式"><a class="anchor" href="#简单工厂模式">#</a> 简单工厂模式</h4><p>首先，简单工厂模式不属于 23 种设计模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂。</p><p>普通简单工厂就是建立一个工厂类，对实现了同一 接口的一些类进行实例的创建。</p><details class="primary"><summary>非静态</summary><div><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 产品接口</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">String</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 具体产品 A</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ConcreteProductA</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token string">"Result of ConcreteProductA"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 具体产品 B</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ConcreteProductB</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> <span class="token string">"Result of ConcreteProductB"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">// 简单工厂</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token class-name">String</span> productType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>productType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">case</span> <span class="token string">"A"</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">case</span> <span class="token string">"B"</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">default</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unknown product type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token comment">// 客户端代码</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token class-name">SimpleFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token class-name">Product</span> productA <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>productA<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: Result of ConcreteProductA</span></pre></td></tr><tr><td data-num="42"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div></details><details class="success"><summary>静态</summary><div><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 产品接口</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">String</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 具体产品 A</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ConcreteProductA</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token keyword">return</span> <span class="token string">"Result of ConcreteProductA"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 具体产品 B</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">ConcreteProductB</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token keyword">return</span> <span class="token string">"Result of ConcreteProductB"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">// 简单工厂</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Product</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token class-name">String</span> productType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>productType<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>            <span class="token keyword">case</span> <span class="token string">"A"</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="27"></td><td><pre>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>            <span class="token keyword">case</span> <span class="token string">"B"</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="29"></td><td><pre>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">default</span><span class="token operator">:</span></pre></td></tr><tr><td data-num="31"></td><td><pre>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Unknown product type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token comment">// 客户端代码</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token class-name">Product</span> productB <span class="token operator">=</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>productB<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出: Result of ConcreteProductB</span></pre></td></tr><tr><td data-num="41"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div></details><p>注意：静态的不需要使用 <code>new</code> 。</p><blockquote><p>活动图、用例设计、类设计、数据设计</p></blockquote><h1 id="第九章-软件测试"><a class="anchor" href="#第九章-软件测试">#</a> 第九章 软件测试</h1><h2 id="软件测试的过程"><a class="anchor" href="#软件测试的过程">#</a> 软件测试的过程</h2><p><strong>缺陷潜在位置</strong>：程序模块内部、程序模块接口、程序模块间的交互、整个软件系统</p><p><img data-src="https://pic4.zhimg.com/v2-a9094a8844d3b7ae4984e9cef0ec3bff_r.jpg" alt="软件测试基础知识点小结 - 知乎"></p><div class="note primary"><p>循序渐进 、逐层递进地开展软件测试</p></div><h3 id="单元测试"><a class="anchor" href="#单元测试">#</a> 单元测试</h3><p>对软件基本模块单元进行测试</p><blockquote><p>过程、函数、方法、类</p></blockquote><p>大多采用<strong>白盒测试技术</strong></p><details class="info"><summary>测试内容</summary><div><ul><li>模块接口测试</li><li>模块局部数据结构测试</li><li>模块独立执行路径测试</li><li>模块错误处理通道测试</li><li>模块边界条件测试</li></ul></div></details><p>产生测试用例、执行测试程序、 生成测试报告</p><h3 id="程序单元测试"><a class="anchor" href="#程序单元测试">#</a> 程序单元测试</h3><ul><li>测试对象 - 程序单元<ul><li>基本模块单元</li><li>基本类方法、函数和过程</li></ul></li><li>测试内容 - 四个方面<ul><li>执行路径</li><li>错误处理</li><li>模块接口</li><li>边界条件</li></ul></li><li>测试依据 - 设计文档<ul><li>程序流程</li></ul></li></ul><div class="note primary"><p>程序单元是构成软件系统 的基本要素，必须对其进行测试以发现缺陷</p></div><details class="info"><summary>考虑因素</summary><div><p>作业：</p><p>① 调用其他模块时所给实际参数的个数是否与被调模块的形参个数相同；</p><p>② 调用其他模块时所给实际参数的属性是否与被调模块的形参属性匹配；</p><p>③ 调用其他模块时所给实际参数的量纲是否与被调模块的形参量纲一致；</p><p>④ 调用预定义函数时所用参数的个数、属性和次序是否正确；</p><p>⑤ 是否存在与当前入口点无关的参数引用；</p><p>⑥ 是否修改了只读型参数；</p><p>⑦ 对全程变量的定义各模块是否一致；</p><p>⑧ 是否把某些约束作为参数传递。</p></div></details><h4 id="quiz"><a class="anchor" href="#quiz">#</a> quiz</h4><ol><li class="quiz fill"><p>书写标识符时忽略了大小写字母的区别。<span class="gap"></span>。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>在 C 语言中，标识符是区分大小写的。如果在程序中使用了大小写不同但名称相似的标识符，可能会导致错误。</p></blockquote></li><li class="quiz fill"><p>忽略了变量的类型，进行了不合法的运算。<span class="gap"></span>。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">float</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token operator">%</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>在 C 语言中，不同类型的变量有不同的合法运算。这里定义了 <code>float</code> 类型的变量却进行了不适合浮点数的运算。</p></blockquote></li><li class="quiz fill"><p>输入变量时忘记加地址运算符 “&amp;”。<span class="gap"></span>。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure></blockquote></li><li class="quiz fill"><p>输入数据的方式与要求不符。<span class="gap"></span>。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>又如<span class="token operator">:</span> <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"a=%d,b=%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><ol><li></li></ol><ul class="task-list danger"><li class="task-list-item"><input type="checkbox" id="cbx_4" checked disabled><label for="cbx_4">xy</label></li><li class="task-list-item"><input type="checkbox" id="cbx_5" disabled><label for="cbx_5">x y</label></li></ul><ol start="2"><li></li></ol><ul class="task-list danger"><li class="task-list-item"><input type="checkbox" id="cbx_6" checked disabled><label for="cbx_6">x,y</label></li><li class="task-list-item"><input type="checkbox" id="cbx_7" disabled><label for="cbx_7">xy</label></li><li class="task-list-item"><input type="checkbox" id="cbx_8" disabled><label for="cbx_8">x y</label></li></ul><ol start="3"><li></li></ol><ul class="task-list danger"><li class="task-list-item"><input type="checkbox" id="cbx_9" disabled><label for="cbx_9">x,y</label></li><li class="task-list-item"><input type="checkbox" id="cbx_10" disabled><label for="cbx_10">xy</label></li><li class="task-list-item"><input type="checkbox" id="cbx_11" disabled><label for="cbx_11">x y</label></li><li class="task-list-item"><input type="checkbox" id="cbx_12" checked disabled><label for="cbx_12">a=x,b=y</label></li></ul></blockquote></li><li class="quiz true"><p>判断输入满足要求: c1=a,c2=b,c3=c 。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c%c%c"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c1<span class="token punctuation">,</span><span class="token operator">&amp;</span>c2<span class="token punctuation">,</span><span class="token operator">&amp;</span>c3<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>输入<span class="token operator">:</span>a b c</pre></td></tr></table></figure><blockquote><p>在 C 语言中，使用 <code>%c</code> 格式输入字符时，空格字符和转义字符都作为有效字符输入，与预期的输入格式可能不一致。</p></blockquote></li><li class="quiz fill"><p>输入输出的数据类型与所用格式说明符不一致<span class="gap"></span>。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>a 已定义为整型，b 定义为实型。</pre></td></tr><tr><td data-num="2"></td><td><pre>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">4.5</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%f%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><blockquote><p>在 C 语言中，输入输出的数据类型需要与所用的格式说明符匹配，否则会导致错误的结果。</p></blockquote></li><li class="quiz"><p>将字符常量与字符串常量混淆<span class="gap"></span>.</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> c<span class="token punctuation">;</span></pre></td></tr></table></figure><ul class="options"><li class="correct"><code>c='a'</code></li><li><code>c=&quot;a&quot;</code></li></ul><blockquote><p>字符串用<span class="red">双引号</span>，char 是<span class="red">单引号</span>.</p></blockquote></li></ol><h4 id="单元测试-独立路径"><a class="anchor" href="#单元测试-独立路径">#</a> 单元测试 - 独立路径</h4><p>在模块中应对每一条独立执行路径进行测试，单元测试的基本任务是保证模块中<strong>每条语句至少执行一次</strong>。此时基本路径测试和循环测试是最常用且最有效的测试技术。</p><h3 id="集成测试"><a class="anchor" href="#集成测试">#</a> 集成测试</h3><ul><li>测试对象<ul><li>对软件模块之间的接口进行测试</li><li>过程调用、函数调用、消息传递、远程过程调用</li></ul></li><li>测试技术<ul><li>采用<strong>黑盒测试技术</strong></li></ul></li><li>集成测试的内容<ul><li>过程调用</li><li>函数调用</li><li>消息传递</li><li>远程过程调用</li><li>网络消息</li></ul></li></ul><h4 id="集成测试方法"><a class="anchor" href="#集成测试方法">#</a> 集成测试方法</h4><ul><li>自顶向下集成：深度优先或者广度优先的策略把各个模块进行组装和测试</li><li>自底向上集成：自底向上进行组装和测试</li></ul><h3 id="确认测试"><a class="anchor" href="#确认测试">#</a> 确认测试</h3><p><strong>一、确认测试概述</strong></p><ol><li>测试对象：对软件的功能和性能进行测试，判断目标软件系统是否满足用户需求。</li><li>依据和标准：软件需求规格说明书。</li><li>测试技术：采用<strong>黑盒测试技术</strong>，包括性能、安全、强度等其他测试。</li></ol><p><strong>二、单元测试、集成测试与确认测试的关系</strong><br>提及单元测试和集成测试，与确认测试一同作为软件测试的不同阶段。</p><p><strong>三、确认测试计划设计时间</strong><br><span class="red"><strong>在需求分析阶段就可以设计确认测试用例及计划。</strong></span></p><p><strong>四、α 测试</strong></p><ol><li>由软件开发公司组织内部人员模拟各类用户行为对即将面市的软件产品（称为 α 版本、内部测试版）进行测试，发现错误并修正。</li><li><ins>尽可能逼真地模拟实际运行环境和用户对软件产品的操作，并尽最大努力涵盖所有可能的用户操作方式</ins>。</li><li>经 α 测试并进行修改后的软件产品称为 β 版本（也称外部测试版）</li></ol><p><strong>五、β 测试</strong></p><ol><li>软件开发公司组织各方面的典型用户在日常工作中实际使用 β 版本，或为对外进行宣传而将 β 版本免费赠送给典型用户（很多情况下，β 版本可以通过 Internet 免费下载，也可以向软件公司索取），并要求用户报告异常情况、提出批评意见。</li><li><ins>β 测试是在与开发者无法控制的环境下进行的软件现场应用</ins>。</li></ol><h3 id="非功能性测试"><a class="anchor" href="#非功能性测试">#</a> 非功能性测试</h3><p>性能测试、强度测试、配置和兼容性测试、安全性测试、可靠性测试、用户界面测试、本地化测试、Web 测试、安装测试。</p><h2 id="软件测试原则"><a class="anchor" href="#软件测试原则">#</a> 软件测试原则</h2><p>软件测试原则如下：</p><ul><li><strong>测试应有计划</strong>：在开发初期就应制定测试计划，且应在测试之前完成。</li><li><strong>以用户需求为导向</strong>：所有测试都应追溯到用户需求。</li><li><strong>应用 Pareto 原则</strong>：80% 的错误在大概 20% 的模块中能找到根源。</li><li><strong>测试从微观到宏观</strong>。</li><li><strong>穷举测试不可行</strong>。</li><li><strong>定义预期输出</strong>：每个测试用例都必须定义预期的输出或结果。</li><li><strong>避免开发人员自测</strong>：尽量避免程序的开发人员测试自己编写的代码，也尽量避免程序开发组织测试其开发的程序。</li><li><strong>详细检查测试结果</strong>：应详细检查每次测试的结果，测试用例不仅要测试有效的输入条件，还要测试不期望的非法输入条件。</li><li><strong>全面检查程序行为</strong>：检查一个程序没有完成希望它做的事情只是测试的一半任务，还应检查程序是否执行了不希望它做的事情。</li><li><strong>不随意舍弃测试用例</strong>：避免随意舍弃任何测试用例，即使非常简单的测试用例。</li><li><strong>避免预设无错</strong>：不应在事先假设不会发现错误的情况下来制定测试计划。</li><li><strong>错误可能性与模块规模相关</strong>：程序模块存在更多错误的可能性与现存错误的数量成正比。</li><li><strong>测试具有创新性和挑战</strong>：测试是一个具有相当创新性和智力挑战的活动。</li></ul><h2 id="软件测试技术"><a class="anchor" href="#软件测试技术">#</a> 软件测试技术</h2><ul><li><p>白盒测试技术</p><p>基于程序内部的执行流程来设计测试用例</p></li><li><p>黑盒测试技术</p><p>基于程序的外在功能和接口来设计测试用例</p></li></ul><h3 id="白盒测试技术"><a class="anchor" href="#白盒测试技术">#</a> 白盒测试技术</h3><ul><li>设计测试用例思想<ul><li>根据<strong>程序单元内部工作流程</strong>来设计测试用例</li></ul></li><li>发现程序单元缺陷<ul><li>运行待测试的程序，检验程序是否按<strong>内部工作流程</strong>来运行的，如果不是则存在缺陷</li></ul></li><li>特点<ul><li>必须<strong>了解程序的内部工作流程</strong>才能设计测试用例</li></ul></li></ul><p>白盒测试用例设计的<strong>指导原则</strong>包括：</p><ul><li>设计测试用例需考虑内部执行流程并生成测试数据。</li><li>确定设计多少测试用例需遵循覆盖原则。</li><li>测试用例覆盖准则有<ins>语句覆盖、分支覆盖、路径覆盖和基本路径覆盖</ins>。</li></ul><div class="note info"><p>判定覆盖 = 分支覆盖</p></div><details class="primary"><summary>条件覆盖</summary><div><p>条件覆盖：每个条件真假都出现至少一次</p><p>判定条件覆盖：每个条件真假都出现至少一次的同时，每个判断的真假都出现至少一次</p><p>组合条件覆盖：所有条件真假进行组合</p></div></details><h4 id="用例覆盖准则例题"><a class="anchor" href="#用例覆盖准则例题">#</a> 用例覆盖准则例题</h4><ol><li class="quiz"><p>软件测试的目的是<span class="gap"></span>.</p><ul class="options"><li>证明软件的正确性</li><li>找出软件系统中存在的所有错误</li><li>证明软件系统中存在错误</li><li class="correct">尽可能多的发现软件系统中的错误</li></ul></li><li class="quiz multi"><p>使用白盒测试方法时确定测试数据应根据<span class="gap"> AB</span>。</p><ul class="options"><li class="correct">程序的内部逻辑</li><li class="correct">指定的覆盖标准</li><li>程序的复杂程度</li><li>使用说明书</li></ul></li><li class="quiz multi"><p>属于白盒测试的技术是<span class="gap"> BCD</span>。</p><ul class="options"><li>边界值分折</li><li class="correct">语句覆盖</li><li class="correct">判定覆盖</li><li class="correct">条件覆盖</li></ul></li><li class="quiz"><p>软件测试是保证软件质量的重要措施，它的实施应该在<span class="gap"></span>。</p><ul class="options"><li>程序编程阶段</li><li class="correct">软件开发全过程</li><li>软件运行阶段</li><li>软件设计阶段</li></ul></li></ol><h4 id="白盒测试路径测试"><a class="anchor" href="#白盒测试路径测试">#</a> 白盒测试 —— 路径测试</h4><p><strong>一、点覆盖</strong></p><p>点覆盖是指选取足够的测试路径，使得程序控制流图中的每个节点至少被覆盖一次。</p><p><strong>二、边覆盖</strong></p><p>边覆盖要求选取足够的测试路径，使得程序控制流图中的每条边至少被覆盖一次。</p><p><strong>三、路径覆盖</strong></p><p>路径覆盖是选取足够多的测试路径，使得程序中所有可能的路径都至少被执行一次。</p><h3 id="黑盒测试"><a class="anchor" href="#黑盒测试">#</a> 黑盒测试</h3><ul><li>思想<ul><li>根据已知的<strong>程序功能和性能</strong> (<strong>而非内部细节</strong>)， 设计测试用例并通过测试检验程序的每个功能和性能是否正常</li></ul></li><li>依据<ul><li>程序的功能和性能描述</li></ul></li><li>特点<ul><li>知道程序功能和性能，不必了解程序内部结构和处理细节</li></ul></li></ul><details class="info"><summary>黑盒测试发现的错误类型</summary><div><ul><li><p>不正确或遗漏的功能</p></li><li><p>界面错误</p></li><li><p>数据结构或外部数据库访问错误</p></li><li><p>性能错误</p></li><li><p>初始化和终止条件错误</p></li></ul></div></details><h4 id="黑盒测试的特点"><a class="anchor" href="#黑盒测试的特点">#</a> 黑盒测试的特点</h4><p><ins>黑盒测试与软件如何实现无关</ins>，如果软件实现发生变化， 测试用例仍然可以使用</p><p>黑盒测试用例的开发可以与软件实现<ins>并行进行</ins>，能够缩短软件开发周期</p><h4 id="黑盒测试策略"><a class="anchor" href="#黑盒测试策略">#</a> 黑盒测试策略</h4><p>黑盒测试法也称为功能测试，用黑盒测试法设计测试用例有 4 种常用技术：</p><ol><li>等价分类法；</li><li>边界值分析；</li><li>因果图法；</li><li>错误猜测法。</li></ol><h4 id="等价分类法"><a class="anchor" href="#等价分类法">#</a> 等价分类法</h4><ul><li>思想<ul><li>把程序的输入数据集合<ins>按输入条件</ins>划分为若干个等价类</li><li>每一个等价类<ins>对于输入条件而言为一组有效或无效</ins>的输入</li><li>为每一个等价类设计一个测试用例</li></ul></li><li>优点<ul><li>减少测试次数，不丢失发现错误的机会</li></ul></li></ul><blockquote><p>每个<strong>等价类中</strong>的数据<strong>具有相同的测试特征</strong></p></blockquote><ul><li><p>等价分类法的基本原则</p><ol><li>有效等价类：是指对于程序的规格说明来说，是合理的<ins>有意义的输入数据</ins>构成的集合。利用它可以检验程序是否实现<strong>预先规定的功能和性能</strong>。</li><li>无效等价类：是指对于程序的规格说明来说，<ins>是不合理的，是无意义的输入数据构成的集合</ins>。程序员主要利用这一类测试用例来检查程序中<ins>功能和性能的实现是否不符合规格说明要求</ins>。</li></ol><details class="danger"><summary>确定等价类的原则</summary><div><ol><li>如果输入条件<strong>规定了取值范围</strong>，或者是值的个数，则可以<strong>确立<ins class="dot">一个有效等价类</ins>和<ins class="dot">两个无效等价</ins>类</strong>。</li><li>如果输入条件规定了输入值的集合，或 者是规定了 “必须如何” 的条件，这时可确立 ++<strong> 一个有效等价类</strong><ins> {.dot} 和</ins><strong>一个无效等价类</strong> ++{.dot}。</li><li>如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类。</li><li>如果规定了输入数据是一组值，而且程序要对每个输入值分别进行处理。这时可为 ++<strong> 每一个输入值</strong>确立<strong>一个有效等价类</strong><ins> {.dot}。<strong>此外</strong>再针对这组确立</ins>一个无效等价类 ++，它应是<strong>所有不允许输入值的集合</strong>。</li><li>如果规定了输入数据必须遵守的规则，则可以确定<ins class="dot">一个有效等价类 (符合规则)</ins> ，和<ins class="dot">若干个无效等价类 (从不同角度违反则)</ins>。</li><li>如果确知，已划分的等价类中各元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类。</li></ol></div></details></li></ul><div class="note warning"><p>划分等价类<strong>不仅要考虑代表 “有效” 输入值的有效等价类</strong>，还需考虑<strong>代表 “无效” 输入值的无效等价类</strong>。</p><p>每一无效等价类至少要用一个测试用例 ，不然就可能漏掉某一类错误，<strong>但允许若干有效等价类合用同一个测试用例，以便进一步减少测试的次数</strong>。</p></div><p>等价类测试用例确立原则如下：</p><ol><li>为每一个等价类规定唯一编号。</li><li>设计新测试用例尽可能覆盖尚未被覆盖的有效等价类，重复此步骤直至所有有效等价类都被覆盖。</li><li>设计新测试用例使其仅覆盖尚未被覆盖的无效等价类，重复此步骤直至所有无效等价类都被覆盖。</li></ol><h4 id="边界值分析法"><a class="anchor" href="#边界值分析法">#</a> 边界值分析法</h4><p>黑盒测试中的边界值分析法总结如下：</p><ul><li>当输入条件是一范围 <code>(a,b)</code> 时， <code>a、b</code> 以及紧挨 <code>a、b</code> 左右的值应作为测试用例。</li><li>当输入条件为一组数时，选择这组数中的 <code>最大者</code> 和 <code>最小者</code> 以 <code>及次大和次小者</code> 作为测试用例。</li><li>如果程序的内部数据结构是<strong>有界的</strong>，应设计测试用例<strong>使它能够检查该数据结构的边界</strong>。</li></ul><div class="note info 等价分类法与边界值分析法的比较"><ol><li>测试数据选取不同：等价分类法的测试数据在各个等价类允许的值域内任意选取；边界值分析法的测试数据必须在边界值附近选取。</li><li>在公开招工的例子中，采用等价分类法设计了 8 个测试用例而边界值分析法则设计了 13 个，所以，<span class="green"><strong>一般来说 ，用边界值分析法设计的测试用例要比等价分类法的代 表性更广，发现错误的能力也更强</strong></span>。但是对边界的分析与确定比较复杂，它要求测试人员具有更多的<strong>经验和创造性</strong>。</li></ol></div><h4 id="错误猜测法"><a class="anchor" href="#错误猜测法">#</a> 错误猜测法</h4><p>所谓猜测，就是猜测被测程序在哪些地方容易出错，然后<strong>针对可能的薄弱环节来设计测试用例</strong>。 显然<strong>它比前两种方法更多地依靠测试人员的直觉与经验</strong>。所以<ins>一般都先用前两方法设计测试用例然后 再用猜测法去补充一些例子作为辅助的手段</ins>。</p><h4 id="因果图法"><a class="anchor" href="#因果图法">#</a> 因果图法</h4><p>因果图是借助图形来设计测试用例的一种系统方法。它适用于被测程序具有多种输入条件， 程序的输出又依赖于输入条件的各种组合的情况 。</p><p>因果图是一种简化了的逻辑图，它能直观地表明程序输入条件（原因）和输出动作（结果） 之间的相互关系。</p><h3 id="测试技术小结"><a class="anchor" href="#测试技术小结">#</a> 测试技术小结</h3><table><thead><tr><th>分类</th><th>测试对象</th><th>测试要求</th><th>采用技术</th></tr></thead><tbody><tr><td>黑盒测试</td><td>程序的功能</td><td>逐一验证程序的功能</td><td>等价分类法、边界分析法、错误猜测法、因果图法</td></tr><tr><td>白盒测试</td><td>程序的结构</td><td>程序的每一组成部分至少被测试一次</td><td>逻辑覆盖法、路径测试法</td></tr></tbody></table><h2 id="summary-6"><a class="anchor" href="#summary-6">#</a> Summary</h2><ul><li>软件测试是为了<strong>发现软件中的缺陷</strong>，原理是<ins>设计和运行测试用例</ins>。</li><li>软件测试方法包括白盒测试、黑盒测试，具体为<strong>设计测试用例、运行测试代码、发现问题</strong>。</li><li>软件测试的<strong>活动、过程和策略</strong>有<ins>单元测试、集成测试、确认测试</ins>。</li><li>基于测试结果进行<strong>纠错</strong>，包括<ins>测试、调试和纠错</ins>。</li></ul><h1 id="第十章-软件维护与演化"><a class="anchor" href="#第十章-软件维护与演化">#</a> 第十章 软件维护与演化</h1><p>软件维护的形式</p><p>・软件维护技术</p><details class="info"><summary>软件逻辑老化</summary><div><p>软件在维护和演化的过程中出现的<ins>用户满意度降低、质量逐渐下降、变更成本不断上升</ins>这样一种现象.</p></div></details><h2 id="软件维护的形式"><a class="anchor" href="#软件维护的形式">#</a> 软件维护的形式</h2><p>❑纠正性维护 ❑完善性维护 ❑适应性维护 ❑预防性维护</p><details class="primary"><summary>软件维护的形式</summary><div><p><strong>纠错性维护</strong>（Corrective Maintenance）对在测试阶段未能发现的，在软件投入使用后才逐渐暴露出来的错误的测试、诊断、定位、纠错以及验证、修改的回归测试过程</p><p><strong>适应性维护</strong>（Adaptive Maintenance） 由于新的硬件设备不断推出，操作系统和编译系统也不断地升级，<ins>为了使软件能适应新的环境</ins>而引起的<ins>程序修改和扩充活动</ins>称为适应性维护。</p><p><strong>改善性维护</strong>（Perfective Maintenance） 在软件的使用过程中，<ins>用户往往会对软件提出新的功能与性能要求</ins>。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。</p><p><strong>预防性维护</strong>（Preventive Maintenance） 为了<ins>进一步改善软件的可靠性和易维护性</ins>，或者<ins>为将来的维护奠定更好的基础</ins>而对软件进行修改。<ins>这类维护很难</ins>。</p></div></details><h3 id="软件维护的特点"><a class="anchor" href="#软件维护的特点">#</a> 软件维护的特点</h3><ol><li><strong>同步性</strong>：软件维护需要与软件使用同步进行。</li><li><strong>周期长</strong>：软件维护周期比开发周期更长，一些软件会服役十几年甚至几十年。</li><li><strong>费用高</strong>：维护成本高达总成本的 80% 以上，维护费用是开发费用的 3 倍以上。</li><li><strong>难度大</strong>：充分理解待维护软件的架构、设计和代码极其困难，尤其是在软件设计文档缺失的情况下问题更为突出，50%-90% 的时间被消耗在理解程序上。</li></ol><h3 id="习题"><a class="anchor" href="#习题">#</a> 习题</h3><ol><li class="quiz fill"><p>微软的操作系统补丁是属于<span class="gap">纠错性</span>维护。</p></li><li class="quiz fill"><p>某政府发现数据库容量日益增大，原有 ACCESS 小型报表系统不能满足要求，需要将数据库移植到 SQL SERVER 中，此属于<span class="gap">适应性</span>维护。</p></li><li class="quiz fill"><p>QQ 的版本升级属于<span class="gap">完善性</span>维护。</p></li><li class="quiz fill"><p>杀毒软件病毒库的更新属于<span class="gap">完善性</span>维护。</p></li><li class="quiz fill"><p>Delphi 原来是运行在 windows 下的编程软件，现在 Borland 公司要开发新版本可以运行在 Unix 下，请问这是<span class="gap">适应性</span>维护。</p></li></ol><h2 id="软件维护的技术"><a class="anchor" href="#软件维护的技术">#</a> 软件维护的技术</h2><p><strong>一、面向维护的技术</strong><br>在软件开发阶段用来减少错误、提高软件可维护性的技术，涉及软件开发的所有阶段，主要关注可维护性的三个方面即<ins>可测试性、可理解性、可修改性</ins>。</p><p><strong>二、软件支援技术</strong><br>在软件维护阶段用于<strong>提高维护工作效率和质量的技术</strong>，主要用到<strong>测试</strong>阶段的技术，包括<ins>信息收集、错误原因分析、软件分析与理解、维护方案评价、代码与文档的修改、修改后的确认</ins>等。</p><p><strong>三、软件维护中应注意的问题</strong><br>维护过程中应谨慎，合理使用工具。</p><h3 id="代码重组"><a class="anchor" href="#代码重组">#</a> 代码重组</h3><p>在<strong>不改变软件功能的前提</strong>下，对程序代码进行重新组织，使得重组后的代码具有更好的<strong>可维护性</strong>，能够有效支持对代码的变更</p><h3 id="逆向工程"><a class="anchor" href="#逆向工程">#</a> 逆向工程</h3><ul><li>基于<strong>低抽象层次</strong>软件制品，通过对其进行理解和分析，产生<strong>高抽象层次</strong>的软件制品。<ul><li>通过对程序代码进行逆向的分析：产生与代码相一致的设计模型和文档。</li><li>基于对程序代码和设计模型的理解，逆向分析出软件系统的需求模型和文档。</li></ul></li><li>典型应用场景：<ul><li>分析已有程序：寻求比源代码更高层次的抽象形式（如设计甚至需求）</li></ul></li></ul><h3 id="设计重构"><a class="anchor" href="#设计重构">#</a> 设计重构</h3><p><strong>一、设计重构的背景</strong><br>如果软件设计文档缺失、软件文档与程序代码不一致或软件设计内容不详实。</p><p><strong>二、设计重构的方法</strong><br>通过读入程序代码，理解和分析代码中的以下方面信息：</p><ol><li>变量使用；</li><li>模块内部封装；</li><li>模块之间的调用或消息传递；</li><li>程序的控制路径。</li></ol><p><strong>三、设计重构的性质</strong><br>是<strong>逆向工程的一种具体表现形式</strong>。<ins>产生用自然语言或图形化信息所描述的软件设计文档。</ins></p><h3 id="再工程"><a class="anchor" href="#再工程">#</a> 再工程</h3><p>通过分析和变更软件的架构，实现更高质量的软件系统的 过程</p><p>再工程既包括<strong>逆向工程也包括正向工程</strong></p><details class="success"><summary>软件再工程过程</summary><div><p>（1）库存目录分析</p><p>（2）文档重构</p><p>（3）逆向工程：分析程序以便在比源代码更高的抽象层次上创建出程序的某种描述的过程</p><p>（4）代码重构</p><p>（5）数据重构</p><p>（6）正向工程：也称革新或改造，不仅仅从现有程序恢复设计信息，而且使用该信息去改变或重构现有系统，以提高其整体质量。</p></div></details><p><img data-src="https://tse1-mm.cn.bing.net/th/id/OIP-C.GnXD1FcaFUEeJVtyeSwg5AHaFh?rs=1&amp;pid=ImgDetMain" alt="[gbc氵]安和昴"></p><p>ƪ(˘⌣˘)ʃ <code>END</code></p><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-11-03 13:41:02" itemprop="dateModified" datetime="2024-11-03T13:41:02+08:00">2024-11-03</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Suivez <i class="ic i-at"><em>@</em></i>Shoka</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" title="软件工程导论">http://example.com/2024/10/21/ComputerScience/软件工程导论/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/05/02/Mathematics/%E9%87%8D%E7%A7%AF%E5%88%86/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;images5.alphacoders.com&#x2F;120&#x2F;1200477.jpg" title="未命名"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div><div class="item right"><a href="/2024/10/21/ComputerScience/papernote/EfficientExactSubgraph/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;cdn.cdnjson.com&#x2F;tvax3.sinaimg.cn&#x2F;&#x2F;large&#x2F;0072Vf1pgy1foxkc7d4wnj31hc0u0aqh.jpg" title="Efficient Exact Subgraph Matching via GNN-based Path Dominance Embedding"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> vldb</span><h3>Efficient Exact Subgraph Matching via GNN-based Path Dominance Embedding</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">第一章 软件及其特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">软件生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">软件特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">软件分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">开源软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">软件质量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">当前软件特征的变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary"><span class="toc-number">1.5.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8F%91%E5%B1%95%E8%84%89%E7%BB%9C"><span class="toc-number">2.</span> <span class="toc-text">第二章 软件工程发展脉络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">软件工程产生背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%86%85%E6%B6%B5"><span class="toc-number">2.2.</span> <span class="toc-text">软件工程基本内涵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">何为软件工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.2.2.</span> <span class="toc-text">软件工程三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AD%A6"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">方法学</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">软件开发的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">软件工程的发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8F%91%E5%B1%95%E7%9A%84%E6%8A%80%E6%9C%AF%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.1.</span> <span class="toc-text">软件工程发展的技术特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-2"><span class="toc-number">2.4.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">第三章 软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">何为软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">软件开发的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">软件过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B-software-process-model"><span class="toc-number">3.1.3.</span> <span class="toc-text">软件过程模型 Software Process Model</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">有哪些软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B-waterfall-model"><span class="toc-number">3.2.1.</span> <span class="toc-text">瀑布模型 Waterfall Model</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#waterfall"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">Waterfall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#detail"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">Detail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limitation"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">Limitation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E5%B8%A6%E5%8F%8D%E9%A6%88%E5%92%8C%E5%9B%9E%E6%BA%AF"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">改进的瀑布模型：带反馈和回溯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8Bincremental-model"><span class="toc-number">3.2.2.</span> <span class="toc-text">增量模型 (Incremental Model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8Biterative-model"><span class="toc-number">3.2.3.</span> <span class="toc-text">迭代模型 (Iterative Model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8Bprototype-model"><span class="toc-number">3.2.4.</span> <span class="toc-text">原型模型 (Prototype Model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8Bspiral-model"><span class="toc-number">3.2.5.</span> <span class="toc-text">螺旋模型 (Spiral Model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.6.</span> <span class="toc-text">不同软件模型的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95agile-method"><span class="toc-number">3.3.</span> <span class="toc-text">敏捷软件开发方法 (Agile Method)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-3"><span class="toc-number">3.4.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">第四章 软件需求分析基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%8C%96%E6%8E%98%E7%9A%84%E6%9D%A5%E6%BA%90%E5%88%A9%E7%9B%8A%E7%9B%B8%E5%85%B3%E6%96%B9"><span class="toc-number">4.1.</span> <span class="toc-text">需求挖掘的来源：利益相关方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">软件需求的类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">面向对象需求分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">需求工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E7%9A%844%E4%B8%AA%E8%A6%81%E7%82%B9"><span class="toc-number">4.3.2.</span> <span class="toc-text">面相对象的 4 个要点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1object%E5%B1%9E%E6%80%A7attribute%E6%96%B9%E6%B3%95method"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">对象 (Object)，属性（Attribute），方法（Method）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5-%E7%B1%BBclass%E4%B8%8E%E5%AE%9E%E4%BE%8Binstance"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">面向对象的概念 - 类（Class）与实例（Instance）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5-%E6%B6%88%E6%81%AFmessage"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">面向对象的概念 - 消息 (Message)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.3.</span> <span class="toc-text">面向对象的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85encapsulation"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">封装（Encapsulation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFinheritance"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">继承（Inheritance）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">4.3.3.2.1.</span> <span class="toc-text">多态性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.3.2.2.</span> <span class="toc-text">引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96override"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">覆盖 (Override)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDoverload"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">重载 (Overload)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82"><span class="toc-number">4.3.4.</span> <span class="toc-text">初步软件需求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">自然语言描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8E%9F%E5%9E%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">软件原型描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uml-%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">UML 建模语言描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ruprational-unified-process"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">RUP（Rational Unified Process）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.5.</span> <span class="toc-text">用例图描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">用例建模</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.3.5.1.1.</span> <span class="toc-text">系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%80%85actor"><span class="toc-number">4.3.5.1.2.</span> <span class="toc-text">执行者 (Actor)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BE%8Buse-case"><span class="toc-number">4.3.5.1.3.</span> <span class="toc-text">用例 (Use Case)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.3.5.1.4.</span> <span class="toc-text">用例间的关系</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">需求分析过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-4"><span class="toc-number">4.5.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">第五章 软件分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.1.</span> <span class="toc-text">软件分析的任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE"><span class="toc-number">5.1.1.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-number">5.1.2.</span> <span class="toc-text">状态图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uml%E7%8A%B6%E6%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">UML 状态图的基本组成要素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">5.1.3.</span> <span class="toc-text">顺序图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">软件分析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-number">5.2.1.</span> <span class="toc-text">面向对象分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">构建对象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.3.</span> <span class="toc-text">动态模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">功能模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.2.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-5"><span class="toc-number">5.3.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">6.</span> <span class="toc-text">第六章 软件设计基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%B4%A8%E9%87%8F%E8%A6%81%E6%B1%82"><span class="toc-number">6.1.</span> <span class="toc-text">软件设计的质量要求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.</span> <span class="toc-text">软件设计基本原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.1.</span> <span class="toc-text">抽象原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96-%E9%AB%98%E5%86%85%E8%81%9A%E5%BA%A6%E5%92%8C%E4%BD%8E%E8%80%A6%E5%90%88%E5%BA%A6%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.2.</span> <span class="toc-text">模块化、高内聚度和低耦合度原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">6.2.3.</span> <span class="toc-text">例题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.4.</span> <span class="toc-text">信息隐藏原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.5.</span> <span class="toc-text">关注点分离原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%87%8D%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.6.</span> <span class="toc-text">软件重用原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%B6%E4%BB%96%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.7.</span> <span class="toc-text">软件设计的其他原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">第七章 面向对象的软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.1.</span> <span class="toc-text">软件体系结构设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">7.1.1.</span> <span class="toc-text">分层体系结构风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8%E9%A3%8E%E6%A0%BC"><span class="toc-number">7.1.2.</span> <span class="toc-text">管道与过滤器风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E6%9D%BF%E9%A3%8E%E6%A0%BC"><span class="toc-number">7.1.3.</span> <span class="toc-text">黑板风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E6%9D%BF%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.1.3.1.</span> <span class="toc-text">黑板风格的约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E6%9D%BF%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">7.1.3.2.</span> <span class="toc-text">黑板风格的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mvc%E9%A3%8E%E6%A0%BC"><span class="toc-number">7.1.4.</span> <span class="toc-text">MVC 风格</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mvc%E9%A3%8E%E6%A0%BC%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.1.4.1.</span> <span class="toc-text">MVC 风格约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#soa%E9%A3%8E%E6%A0%BC"><span class="toc-number">7.1.5.</span> <span class="toc-text">SOA 风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BF%E9%A3%8E%E6%A0%BC"><span class="toc-number">7.1.6.</span> <span class="toc-text">消息总线风格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.2.</span> <span class="toc-text">软件详细设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-number">7.2.1.</span> <span class="toc-text">详细设计的工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BEn-s%E5%9B%BE"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">结构化流程图（N-S 图）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pad%E5%9B%BE"><span class="toc-number">7.2.1.2.</span> <span class="toc-text">PAD 图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">设计模式类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">简单工厂模式</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">第九章 软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">软件测试的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">8.1.1.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">8.1.2.</span> <span class="toc-text">程序单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#quiz"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">quiz</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-%E7%8B%AC%E7%AB%8B%E8%B7%AF%E5%BE%84"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">单元测试 - 独立路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">8.1.3.</span> <span class="toc-text">集成测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">集成测试方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E6%B5%8B%E8%AF%95"><span class="toc-number">8.1.4.</span> <span class="toc-text">确认测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E6%B5%8B%E8%AF%95"><span class="toc-number">8.1.5.</span> <span class="toc-text">非功能性测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%8E%9F%E5%88%99"><span class="toc-number">8.2.</span> <span class="toc-text">软件测试原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">8.3.</span> <span class="toc-text">软件测试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">8.3.1.</span> <span class="toc-text">白盒测试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E8%A6%86%E7%9B%96%E5%87%86%E5%88%99%E4%BE%8B%E9%A2%98"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">用例覆盖准则例题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95%E8%B7%AF%E5%BE%84%E6%B5%8B%E8%AF%95"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">白盒测试 —— 路径测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">8.3.2.</span> <span class="toc-text">黑盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.3.2.1.</span> <span class="toc-text">黑盒测试的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-number">8.3.2.2.</span> <span class="toc-text">黑盒测试策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E5%88%86%E7%B1%BB%E6%B3%95"><span class="toc-number">8.3.2.3.</span> <span class="toc-text">等价分类法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">8.3.2.4.</span> <span class="toc-text">边界值分析法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%8C%9C%E6%B5%8B%E6%B3%95"><span class="toc-number">8.3.2.5.</span> <span class="toc-text">错误猜测法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95"><span class="toc-number">8.3.2.6.</span> <span class="toc-text">因果图法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E5%B0%8F%E7%BB%93"><span class="toc-number">8.3.3.</span> <span class="toc-text">测试技术小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-6"><span class="toc-number">8.4.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%BC%94%E5%8C%96"><span class="toc-number">9.</span> <span class="toc-text">第十章 软件维护与演化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">软件维护的形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">9.1.1.</span> <span class="toc-text">软件维护的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">9.1.2.</span> <span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4%E7%9A%84%E6%8A%80%E6%9C%AF"><span class="toc-number">9.2.</span> <span class="toc-text">软件维护的技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%87%8D%E7%BB%84"><span class="toc-number">9.2.1.</span> <span class="toc-text">代码重组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B"><span class="toc-number">9.2.2.</span> <span class="toc-text">逆向工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%87%8D%E6%9E%84"><span class="toc-number">9.2.3.</span> <span class="toc-text">设计重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E5%B7%A5%E7%A8%8B"><span class="toc-number">9.2.4.</span> <span class="toc-text">再工程</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2020/08/13/special/" rel="bookmark" title="Step.4 主题特殊功能">Step.4 主题特殊功能</a></li><li><a href="/2023/03/19/ComputerScience/WebSecurity/CTF/%E5%AD%A6%E4%B9%A0SQL/" rel="bookmark" title="SQL注入">SQL注入</a></li><li class="active"><a href="/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" rel="bookmark" title="软件工程导论">软件工程导论</a></li><li><a href="/2024/10/21/ComputerScience/papernote/EfficientExactSubgraph/" rel="bookmark" title="Efficient Exact Subgraph Matching via GNN-based Path Dominance Embedding">Efficient Exact Subgraph Matching via GNN-based Path Dominance Embedding</a></li><li><a href="/2024/10/24/ComputerScience/papernote/EventPromoteInhibitRelationMining/" rel="bookmark" title="EventPromoteInhibitRelationMining">EventPromoteInhibitRelationMining</a></li><li><a href="/2024/10/25/hello-world/" rel="bookmark" title="Hello World">Hello World</a></li><li><a href="/2024/10/25/ComputerScience/WebSecurity/CTF/CTF%E9%A2%98%E7%9B%AE%E7%AC%94%E8%AE%B0/" rel="bookmark" title="CTFNote">CTFNote</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Suivez" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Suivez</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">9</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">7</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/05/02/Mathematics/%E9%87%8D%E7%A7%AF%E5%88%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/10/21/ComputerScience/papernote/EfficientExactSubgraph/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/Mathematics/" title="分类于 Mathematics">Mathematics</a></div><span><a href="/2023/03/19/Mathematics/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%80/" title="高等数学笔记一">高等数学笔记一</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerscience/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/2024/10/25/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Mathematics/" title="分类于 Mathematics">Mathematics</a></div><span><a href="/2023/03/19/Mathematics/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0%E4%B8%80/" title="线性代数笔记一">线性代数笔记一</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerscience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerscience/websecurity/" title="分类于 网络安全">网络安全</a> <i class="ic i-angle-right"></i> <a href="/categories/computerscience/websecurity/CTF/" title="分类于 CTF">CTF</a></div><span><a href="/2024/10/25/ComputerScience/WebSecurity/CTF/CTF%E9%A2%98%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="CTFNote">CTFNote</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerscience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerscience/papernote/" title="分类于 论文读记">论文读记</a></div><span><a href="/2024/10/24/ComputerScience/papernote/EventPromoteInhibitRelationMining/" title="EventPromoteInhibitRelationMining">EventPromoteInhibitRelationMining</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerscience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerscience/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/" title="分类于 二进制杂谈">二进制杂谈</a> <i class="ic i-angle-right"></i> <a href="/categories/computerscience/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9D%82%E8%B0%88/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/2020/08/13/special/" title="Step.4 主题特殊功能">Step.4 主题特殊功能</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Mathematics/" title="分类于 Mathematics">Mathematics</a></div><span><a href="/2023/03/19/Mathematics/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/" title="数学笔记二">数学笔记二</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Mathematics/" title="分类于 Mathematics">Mathematics</a></div><span><a href="/2023/03/19/Mathematics/%E9%94%99%E9%A2%98%E6%9C%AC/" title="错题本">错题本</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/zhaji/" title="分类于 札记">札记</a></div><span><a href="/2022/09/07/zhaji/Note%20of%20markdown/" title="Notes Of Markdown">Notes Of Markdown</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerscience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerscience/papernote/" title="分类于 论文读记">论文读记</a> <i class="ic i-angle-right"></i> <a href="/categories/computerscience/papernote/vldb/" title="分类于 vldb">vldb</a></div><span><a href="/2024/10/21/ComputerScience/papernote/EfficientExactSubgraph/" title="Efficient Exact Subgraph Matching via GNN-based Path Dominance Embedding">Efficient Exact Subgraph Matching via GNN-based Path Dominance Embedding</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Suivez @ Suivez Shoka</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/10/21/ComputerScience/软件工程导论/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,mermaid:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',quiz:{choice:"单选题",multiple:"多选题",true_false:"判断题",essay:"问答题",gap_fill:"填空题",mistake:"错题备注"},ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->