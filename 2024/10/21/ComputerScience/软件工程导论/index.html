<!-- build time:Tue Oct 29 2024 22:49:54 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Shoka" href="http://example.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="Shoka" href="http://example.com/atom.xml"><link rel="alternate" type="application/json" title="Shoka" href="http://example.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="笔记"><link rel="canonical" href="http://example.com/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"><title>软件工程导论 - 计算机科学技术 | Suivez Shoka = Shoka</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">软件工程导论</h1><div class="meta"><span class="item" title="创建时间：2024-10-21 15:42:28"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-10-21T15:42:28+08:00">2024-10-21</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Suivez Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://images5.alphacoders.com/124/1243826.jpg"></li><li class="item" data-background-image="https://cdn.cdnjson.com/tvax3.sinaimg.cn//large/0072Vf1pgy1foxkc7d4wnj31hc0u0aqh.jpg"></li><li class="item" data-background-image="https://images4.alphacoders.com/227/227838.jpg"></li><li class="item" data-background-image="https://images2.alphacoders.com/130/1301855.jpg"></li><li class="item" data-background-image="https://images8.alphacoders.com/129/1296002.jpg"></li><li class="item" data-background-image="https://images5.alphacoders.com/612/612548.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerscience/" itemprop="item" rel="index" title="分类于 计算机科学技术"><span itemprop="name">计算机科学技术</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://example.com/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Suivez"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Shoka"></span><div class="body md" itemprop="articleBody"><h1 id="第一章-软件及其特点"><a class="anchor" href="#第一章-软件及其特点">#</a> 第一章 软件及其特点</h1><h2 id="软件"><a class="anchor" href="#软件">#</a> 软件</h2><p><strong>编写程序步骤</strong></p><ul><li>分析软件需求：文档 数据</li><li>设计软件系统：文档 数据</li><li>编写代码程序：数据 代码</li></ul><blockquote><p>不可或缺，相互依存</p></blockquote><p><strong>软件</strong></p><p>软件是指在计算机系统的支持下，能够完成特定功能与性<br>能的程序、数据和相关文档</p><p><strong>文档</strong></p><p>记录软件开发活动和阶段性成果，软件配置以及变更的阐述性资料</p><ul><li>定义和理解软件</li><li>记录软件开发成果</li><li>辅助不同人员间的交流</li></ul><blockquote><p>软件需求文档、软件设计文档、软件测试文档、软件用户手册......</p><p>目的：阐述、发现问题、交流、管理</p></blockquote><p><strong>数据</strong></p><p>数据是程序的加工处理对象和结果</p><p>✏️ 软件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\ne</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 程序	开发软件 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\ne</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 编写程序</p><hr><p><ins>软件的规模和复杂性意味着要采用行之有效的方法 ——<strong> 工程方法</strong></ins></p><h3 id="软件生命周期"><a class="anchor" href="#软件生命周期">#</a> 软件生命周期</h3><p>从<strong>提出开发</strong>开始到<strong>开发出系统</strong>、<strong>运行维护</strong>以及<strong>最终退役</strong>的全过程</p><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    A<span class="token text string">[需求分析]</span> <span class="token arrow operator">--></span> B<span class="token text string">[软件设计]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    B <span class="token arrow operator">--></span> C<span class="token text string">[编码实现]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    C <span class="token arrow operator">--></span> D<span class="token text string">[软件测试]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    D <span class="token arrow operator">--></span> E<span class="token text string">[部署使用]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    E <span class="token arrow operator">--></span> F<span class="token text string">[使用维护]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="软件特点"><a class="anchor" href="#软件特点">#</a> 软件特点</h3><ul><li><p><strong>逻辑性</strong></p><ul><li>逻辑产品，思维获得的结果，不会磨损和老化</li></ul></li><li><p><strong>复杂性</strong></p><ul><li>规模大、运行复杂</li></ul></li><li><p>设计开发</p></li><li><p>易变性</p></li><li><p>缺陷隐藏性</p></li></ul><h3 id="软件分类"><a class="anchor" href="#软件分类">#</a> 软件分类</h3><p>应用软件、系统软件、支撑软件（辅助软件开发和运维）</p><h2 id="开源软件"><a class="anchor" href="#开源软件">#</a> 开源软件</h2><p><strong>闭源软件</strong></p><p>软件代码不对用户开放的一类软件，购买软件时只提供可运行软件或服务，没有提供源代码</p><blockquote><p>Windows、Office</p><p>IBM、Oracle</p></blockquote><p><strong>开源软件</strong></p><p>一种源代码可以 <strong>自由获取和传播</strong> 的计算机软件，其拥有者通过开源许可证赋予被许可人对软件 <strong>进行使用、修改和传播</strong> 的权力</p><ul><li>好处：自由传播、激发创作者热情、降低成本（free of charge）</li></ul><blockquote><p>Linux、Mysql、Firefox</p></blockquote><blockquote><p>github, gitee, stack overflow</p></blockquote><h2 id="软件质量"><a class="anchor" href="#软件质量">#</a> 软件质量</h2><p>软件质量是指软件满足给定需求的程度，它是 <strong>产品生命线</strong></p><p>可信软件的基本要求：</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" id="cbx_0" checked disabled><label for="cbx_0">安全性</label></li><li class="task-list-item"><input type="checkbox" id="cbx_1" checked disabled><label for="cbx_1">韧性 (Resilience)</label></li><li class="task-list-item"><input type="checkbox" id="cbx_2" checked disabled><label for="cbx_2">隐私性</label></li><li class="task-list-item"><input type="checkbox" id="cbx_3" checked disabled><label for="cbx_3">可靠性</label></li></ul><h2 id="当前软件特征的变化"><a class="anchor" href="#当前软件特征的变化">#</a> 当前软件特征的变化</h2><p><strong>地位和作用</strong>：无处不在，创新工具，使能技术和重要利器，关键性基础设施</p><p><strong>运行环境</strong>：</p><ul><li><p>从前端的 PC 终端、可穿戴设备、智能手机到后端的云中心、高性能计算中心</p></li><li><p>从孤立、独立、局域和可控的计算环境到分布、开发、动态、难控、无处不在的计算环境</p></li></ul><hr><p><strong>软件形态</strong></p><ul><li><p>系统之系统</p><p>诸多系统联盟和组合而成</p></li><li><p>生态系统</p><p>社会、信息、物理等要素共存</p></li><li><p>同构异构多样的系统联盟</p><p>要素异构，客观存在也是必然</p><blockquote><p>大规模复杂信息技术系统是由大量相对独立、自我控制和管理的系统组装而成一系统联盟</p><p><ins>开发系统联盟需要采用社会技术观点，借助系统工程的方法</ins></p></blockquote></li><li><p>非封闭环境 or 系统，是开发环境动态适应系统</p><p>环境和系统相互作用，要素、关系、联盟等持续变化，边界不明确</p></li><li><p><strong>动态演化系统</strong></p></li></ul><p><strong>软件子系统</strong></p><p>由一组面向任务，服务于不同对象的 <strong>子系统</strong> 构成</p><blockquote><p>每个子系统 <strong>独立运作</strong>、通过 <strong>互相交互</strong> 实现全局任务</p></blockquote><p><strong>分布式系统四大形态</strong></p><table><thead><tr><th>对等计算</th><th>区块链</th><th>网格计算</th><th>云计算</th></tr></thead><tbody><tr><td>泛化（old）</td><td>泛化（new）</td><td>集中化（old）</td><td>集中化（new）</td></tr></tbody></table><p><strong>生态系统</strong></p><ul><li><p>运行生态</p><blockquote><p>软件的运行需要依靠 “生态” 的支撑，从计算和物理设备、社会系统到 OS 和运行环境</p></blockquote></li><li><p>演化生态</p><blockquote><p>软件的演化基于特定的 “生态” 支撑 ，从最初的 “源头” 到最新 “版本”</p></blockquote></li><li><p>人员生态</p><blockquote><p>涉及到大量、开放的介入人员，使用者、开发者、运维者等</p></blockquote></li></ul><div class="note info"><p><strong>软件生态：共同环境 + 诸多要素 + 独立演化 + 相互依存</strong></p></div><p><strong>软件系统的应用及示例</strong></p><ul><li>高性能计算 、信息物理系统 、智能机器人 、云计算 、健康医疗 、城市交通 、军事信息系统 、航空航天</li></ul><h2 id="summary"><a class="anchor" href="#summary">#</a> Summary</h2><ul><li><p><strong>软件</strong></p><p>程序 + 文档 + 数据</p></li><li><p><strong>软件特点</strong></p><p>逻辑产品、设计开发、需求易变、系统复杂、缺陷隐蔽</p></li><li><p><strong>开源软件</strong></p><p>代码可自由获取和传播，需遵循许可证，充分利用开源软件</p></li><li><p><strong>软件质量</strong></p><p>多要素，如正确性、可靠性、可信性等</p></li><li><p><strong>软件发生的变化</strong></p><p>地位和作用，形态和复杂性，运行环境，系统规模</p></li></ul><h1 id="第二章-软件工程发展脉络"><a class="anchor" href="#第二章-软件工程发展脉络">#</a> 第二章 软件工程发展脉络</h1><h2 id="软件工程产生背景"><a class="anchor" href="#软件工程产生背景">#</a> 软件工程产生背景</h2><ul><li>作坊式的个人创作<ul><li><strong>依靠个人能力</strong></li><li><strong>缺乏合作</strong></li><li>关注计算存储时空利用， 精雕细琢</li><li>程序规模小且功能单一</li><li><strong>无系统性方法和标准流程</strong></li></ul></li><li>大规模软件开发<ul><li>当软件规模越大，上述挑战就越突出，面临的困难也就越多（规模大、复杂性高的软件）<ul><li>代码量、人员管理、隐蔽性错误越积越多</li></ul></li></ul></li></ul><p><img data-src="https://i0.hdslb.com/bfs/article/8d84c410fd8087eb534064bcea23bf89490570799.png@100q" alt=""></p><p><strong>Leading to</strong></p><ul><li>进度延迟、质量不稳定、成本过高、维护困难、失败风险大</li></ul><hr><p><strong>软件危机产生的根源</strong></p><ul><li>对软件这样一类 <strong>复杂和特殊系统</strong> 的认识不清<ul><li>软件是新生事物，对其特点、规律性和复杂性认识不够</li></ul></li><li>没有找到 <strong>支持软件系统开发的有效方法</strong><ul><li>基础理论、关键技术、开发过程、支撑工具等</li></ul></li><li>缺乏成功软件开发 <strong>实践</strong> 以及相应的开发 <strong>经验</strong><ul><li><ins>系统总结、认真分析、充分借鉴、吸取教训</ins></li></ul></li></ul><blockquote><p>软件开发迫切需要理论和方法指导，软件工程应运而生！</p></blockquote><h2 id="软件工程基本内涵"><a class="anchor" href="#软件工程基本内涵">#</a> 软件工程基本内涵</h2><p>软件工程的诞生</p><p><strong>时间</strong>：1968，<strong>地点</strong>：西德南部小城，<strong>事件</strong>：NATO 科技委出资召开的会议，<strong>人物</strong>：11 个国家 50 位代表参加</p><p><strong>主题</strong>：如何解决软件危机，<strong>成果</strong>：提出了软件工程</p><p><strong>软件工程产生动机</strong></p><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> TD<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    A<span class="token text string">[软件工程]</span> <span class="token arrow operator">--></span><span class="token label property">|解决软件危机|</span> B<span class="token text string">[软件系统开发]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">subgraph</span> 要求<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        C1<span class="token text string">[快速]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        C2<span class="token text string">[高效]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        C3<span class="token text string">[低成本]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        C4<span class="token text string">[高质量]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">end</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    A <span class="token arrow operator">--></span> C1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    A <span class="token arrow operator">--></span> C2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    A <span class="token arrow operator">--></span> C3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    A <span class="token arrow operator">--></span> C4<span class="token punctuation">;</span></pre></td></tr></table></figure><h3 id="何为软件工程"><a class="anchor" href="#何为软件工程">#</a> 何为软件工程</h3><p>软件工程：将 ** 系统的、规范的、可量化 ** 的方法应用于软件的开发、运行和维护的过程</p><p>软件是产品 (Product)：面向用户，存在质量、成本、利润等特征</p><p>软件开发是一项工程 (Project)：存在约束，需要质量保证，进行组织管理</p><p>要按工程化方法来组织软件生产</p><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>A<span class="token text string">[约束]</span><span class="token arrow operator">--></span>B<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>B<span class="token text string">[过程]</span><span class="token arrow operator">--></span>C<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>C<span class="token text string">[质量]</span><span class="token arrow operator">--></span>D<span class="token text string">[成本]</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>软件开发方式的改变：从个体作坊式行为 ➡️ 基于团队的协同开发方式</p><h3 id="软件工程三要素"><a class="anchor" href="#软件工程三要素">#</a> 软件工程三要素</h3><p><img data-src="https://i0.hdslb.com/bfs/article/3913d963dd13223186052ab00236b854490570799.png" alt="3attribute"></p><h4 id="过程"><a class="anchor" href="#过程">#</a> 过程</h4><p>从 <strong>管理</strong> 的视角，回答软件开发、运行和维护需要 <strong>开展哪些工作、按照什么样的步骤和次序来开展工作</strong></p><h4 id="方法学"><a class="anchor" href="#方法学">#</a> 方法学</h4><p>从 <strong>技术</strong> 的视角，回答软件开发、运行和维护如何做的问题</p><p>为软件开发过程中的各项开发和维护活动提供 <strong>系统性、规范性的技术支持</strong></p><div class="note primary 典型成果"><p>✏️ 结构化软件开发方法学 ✏️ 面向对象软件开发方法学 ✏️ 基于构件的软件开发方法学</p></div><h4 id="工具"><a class="anchor" href="#工具">#</a> 工具</h4><p>从 <strong>工具辅助</strong> 的视角，主要回答如何借助工具来 <strong>辅助软件开发、运行和维护</strong> 的问题</p><p>帮助软件开发人员更为高效地运用 <strong>软件开发方法学</strong> 来完成软件开发过程中的各项工作，++ 提高软件开发效率和质量， 加快软件交付进度 ++。</p><blockquote><p>如需求分析、软件设计、编码实现、软件测试、部署运行、软件 维护、项目管理、质量保证等，简化软件开发任务</p></blockquote><h3 id="软件开发的本质"><a class="anchor" href="#软件开发的本质">#</a> 软件开发的本质</h3><p><mark>软件开发 = 软件创作 + 软件生产</mark></p><p>基于软件开发者的经验和技 能，借助于智慧，进行自由创新；基于工程化的手段，遵循约束和规范</p><ul><li><p>软件工程目标</p><p>在 <strong>成本、进度</strong> 等约束下，指导 <strong>软件开发和运维</strong>，开发出满足用户要求的足够好软件</p></li><li><p>软件工程原则</p><ul><li><p>抽象和建模</p><p>抽象：将与相关开发活动所关注的要素提取出来，不关心的要素扔掉，形成与该开发活动相关的软件要素</p><p>建模：基于特定的抽象，借助于 <strong>建模语言</strong>（如数据流图、UML 等），<strong>建立起基于这些抽象的软件模型</strong>，进而促进对软件系统的 准确理解</p></li><li><p>模块化</p><ul><li>将软件系统的功能分 <strong>解和实现为若干个模块</strong>，每个模块具有独立 的功能，模块之间通过接口进行调用和访问。</li></ul></li><li><p><strong>模块内部高内聚，模块间松耦合</strong></p><figure class="highlight mermaid"><figcaption data-lang="mermaid"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">graph</span> LR<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>A<span class="token text string">[函数和过程]</span><span class="token arrow operator">--></span>B<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>B<span class="token text string">[对象类]</span><span class="token arrow operator">--></span>C<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>C<span class="token text string">[软构件]</span><span class="token arrow operator">--></span>D<span class="token text string">[服务及镜像]</span><span class="token punctuation">;</span></pre></td></tr></table></figure></li><li><p>软件重用</p></li></ul></li><li><p>在软件开发过程中 <strong>尽可能利用已有的软件资源和资产</strong>（如函数 库、类库、构件库、开源软件、代码片段等）来实现软件系统</p><ul><li>努力开发出 <strong>可被再次重用的软件资源</strong>（如函数、类、构件等）</li></ul></li></ul><div class="note info"><p>代码重用、设计重用、软件重用</p></div><ul><li><p>信息隐藏</p><ul><li>模块内部信息（如内部的语 句、变量等）<strong>对外不可见或不可访问</strong>，模块间仅仅交换那些为完成系统功能所必需交换的信息（如接口）</li></ul></li><li><p>关注点分离：每一项开发活动中聚焦于某个关注点，整合多个不同视点的开发结果</p></li><li><p><strong>分而治之</strong>：对复杂软件系统进行 分解，形成一组子系统；然后通过整合子系统的问题解决得到整个 系统的问题解；有助于简化复杂软件系统的开发，降低软件开发复杂性，从而提 高软件开发效率，确保复杂软件系统的质量。</p></li><li><p>双向追踪原则</p><ul><li>当某个软件制品发生变化时，<strong>一方面要追踪这种变化会对那些软件制品产生影响</strong>，进而指导相关的开发和维护工作，此为正向追踪；<strong>另一方面要追踪产生这种变化的来源</strong></li></ul></li><li><p>工具辅助：利用软件工具来辅助软件开发和维护工作是一项行之有效的方法</p><p><code>工欲善其事必先利其器</code></p></li></ul><div class="note info"><p><ins class="dot"><strong>软件工程原则</strong></ins>：抽象和建模、模块化、软件重用、信息隐藏、 关注点分离、分而治之、双向追踪、工具辅助</p></div><h2 id="软件工程的发展历程"><a class="anchor" href="#软件工程的发展历程">#</a> 软件工程的发展历程</h2><p><img data-src="https://i0.hdslb.com/bfs/article/cc91c667445a3b9e3d83a6867332f93e490570799.png" alt="软件工程的发展历程"></p><h3 id="软件工程发展的技术特点"><a class="anchor" href="#软件工程发展的技术特点">#</a> 软件工程发展的技术特点</h3><p><ins>抽象的层次越来越高、软件重用的粒度越来越大、软件开发理念的不断变化</ins></p><p>软件工程多学科交叉</p><p><strong>软件工程的变与不变</strong></p><ul><li>目标、基本原则不变；理解认识改变，手段方法改变，学科进一步交叉融合</li></ul><h2 id="summary-2"><a class="anchor" href="#summary-2">#</a> Summary</h2><ul><li><p><strong>软件工程产生的背景和目的</strong></p><p>软件危机，持续存在，关注点不同</p></li><li><p><strong>软件工程的本质</strong></p><ul><li>软件视为产品，软件开发视为工程、创作和生产相结合的过程</li><li>三要素：过程、方法学和工具</li><li>软件工程的基本原则</li></ul></li><li><p><strong>软件工程的发展</strong></p><p>不同阶段和时期，不同的思想和技术</p></li><li><p><strong>软件工程教育</strong></p><p>软件工程知识体系及课程特点</p></li></ul><h1 id="第三章-软件过程模型"><a class="anchor" href="#第三章-软件过程模型">#</a> 第三章 软件过程模型</h1><p><strong>review</strong></p><p>软件的<strong>概念</strong>：文档、数据和程序的集合</p><p>软件的<strong>特点</strong>：逻辑产品、需求多变、设计开发、缺陷隐蔽性</p><p>软件<strong>生命周期</strong>：经历多个不同的阶段</p><p>闭源软件和开源软件：实践状况及优势</p><p>软件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 程序；开发软件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">≠</mo></mrow><annotation encoding="application/x-tex">\neq</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mrel"><span class="mrel"><span class="mord vbox"><span class="thinbox"><span class="rlap"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span></span><span class="mrel">=</span></span></span></span></span> 编写程序；</p><div class="note info"><p><strong>生命周期</strong>：从<strong>提出开发</strong>开始到<strong>开发出系统、运行维护以及最终退役</strong>的全过程</p></div><h2 id="何为软件过程模型"><a class="anchor" href="#何为软件过程模型">#</a> 何为软件过程模型</h2><h3 id="软件开发的特点"><a class="anchor" href="#软件开发的特点">#</a> 软件开发的特点</h3><p>✏️<strong>基于智力的协作过程</strong></p><ul><li>智力活动：基于逻辑思维来构造软件</li><li>交流协作：软件工程师、用户间的交流和讨论</li></ul><p>🪄<strong>软件项目内在复杂性</strong></p><ul><li>介入的人多、考虑的内容多、产生的制品多</li><li>不同要素间存在关联</li></ul><p>🎢<strong>循序渐进的开发过程</strong></p><ul><li>开展有序的开发活动，如编码、分析、设计</li><li>体现了工程的思想：按步骤、分阶段</li></ul><h3 id="软件过程"><a class="anchor" href="#软件过程">#</a> 软件过程</h3><ul><li>过程：获得 + 关系（次序……）</li><li><strong>软件过程</strong>：一系列有序软件<strong>开发活动</strong>（技术活动和管理活动）</li></ul><h3 id="软件过程模型-software-process-model"><a class="anchor" href="#软件过程模型-software-process-model">#</a> 软件过程模型 Software Process Model</h3><p>开发活动</p><ul><li>任务、目标、输入 和输出</li><li>投入人员、工具、资源 和成本等</li><li>活动间的关系和次序</li></ul><h2 id="有哪些软件过程模型"><a class="anchor" href="#有哪些软件过程模型">#</a> 有哪些软件过程模型</h2><p>瀑布模型、增量模型、迭代模型、原型模型、螺旋模型</p><div class="note info"><p>需要系统、规范性的软件过程模型的指导；每种软件过程模型有其各自的特点和适用的场所</p></div><h3 id="瀑布模型-waterfall-model"><a class="anchor" href="#瀑布模型-waterfall-model">#</a> 瀑布模型 Waterfall Model</h3><h4 id="waterfall"><a class="anchor" href="#waterfall">#</a> Waterfall</h4><ul><li><strong>需求分析→概要设计→详细设计→编码实现→集成测试→确认测试</strong></li><li>适合于需求易于定义、 不易变动的软件系统</li></ul><h4 id="detail"><a class="anchor" href="#detail">#</a> Detail</h4><p><strong>需求分析 (Requirement Analysis)</strong> —— 问题是什么</p><ul><li><p>定义软件需求，包括功能、非功能需求</p></li><li class="red"><p>产出：[软件需求模型、软件需求文档、软件确认测试计划 ——<strong> 文档类的软件制品</strong>]</p></li></ul><p><strong>概要设计 (Architecture Design)</strong> —— 问题如何解决</p><ul><li>建立软件总体架构、制定集成测试计划</li><li>产出：<span class="red">软件概要设计模型、软件概要设计文档、软件集成测试计划 ——<strong> 文档类的软件制品</strong></span></li></ul><p><strong>详细设计 (Detailed Design)</strong> —— 问题如何解决</p><ul><li>设计模块内部细节 (算法、数据结构)，制订单元测试计划</li><li>产出：<span class="red">软件详细设计模型、软件详细设计文档、单元测试计划 ——<strong> 文档类的软件制品</strong></span></li></ul><p><strong>编程实现 (Implementation)</strong> —— 实际解决问题</p><ul><li>编写程序代码并进行单元测试和调试</li><li>产出：<span class="red">经过单元测试的源程序代码 ——<strong> 程序类的软件制品</strong></span></li></ul><p><strong>集成测试 (Integration Test)</strong> —— <ins class="dot">问题解决如何？软件有缺陷吗？</ins></p><ul><li>组装软件模块并进行测试以发现问题</li><li>产出：<span class="red">经过集成测试、修复缺陷的源程序代码，集成测试报告 ——<strong> 数据、文档和代码类的软件制品</strong></span></li></ul><p><strong>确认测试 (Validation Test)</strong> —— <ins class="dot">问题解决如何？软件有缺陷吗？</ins></p><ul><li>测试软件是否满足用户需求</li><li>产出：<span class="red">经过确认测试、修复缺陷后的代码，软件确认测试报告 ——<strong> 数据、文档和代码类的软件制品</strong></span></li></ul><h4 id="limitation"><a class="anchor" href="#limitation">#</a> Limitation</h4><p><mark>软件需求具有易变、多变的特点</mark></p><p>瀑布模型的<span class="red"><strong>需求确定，过于理想化，缺乏变通难以应对变化</strong></span></p><h4 id="改进的瀑布模型带反馈和回溯"><a class="anchor" href="#改进的瀑布模型带反馈和回溯">#</a> 改进的瀑布模型：带反馈和回溯</h4><ul><li>后期活动发现有问题后，可返回到前面活动加以解决</li><li>提高了过程模型的灵活性</li><li><mark>不足</mark><ul><li>软件开发处于动荡之中</li><li><strong>需等到所有功能实现后</strong>， 才能得到可运行软件</li></ul></li></ul><h3 id="增量模型incremental-model"><a class="anchor" href="#增量模型incremental-model">#</a> 增量模型 (Incremental Model)</h3><p>需求设计→概要设计→<span class="red"><strong>详细设计→编码实现→集成测试</strong></span>→确认测试</p><p><span class="red"><strong>详细设计→编码实现→集成测试</strong></span> 可以增量（执行 n 次）</p><ul><li>渐进式：增量的实现软件功能</li><li>优点：渐进快速交付，并行开发，提高效率</li><li>局限性：小项目可能不适用；软件需求确定且不 易于变化</li></ul><h3 id="迭代模型iterative-model"><a class="anchor" href="#迭代模型iterative-model">#</a> 迭代模型 (Iterative Model)</h3><p>迭代 n 次：<strong>需求分析→概要设计→详细设计→编码实现→软件测试</strong></p><p>每次迭代完成<ins>部分可确定的软件需求</ins></p><ul><li>每次迭代是一完整过程，体现了小步快跑的开发理念，适合<ins class="red">需求难导出、不易确定且持续变动的软件</ins></li><li>局限性：迭代多少次不确定、管理较为复杂</li></ul><div class="note primary"><p><strong>增量过程模型与迭代过程模型有何区别？</strong></p><p><span class="spoiler bulr" title="你知道得太多了">增量模型（横向扩展）迭代模型（纵向扩展）</span></p></div><details class="info"><summary>软件需求获取是一关键和瓶颈问题</summary><div><ul><li>软件需求非常关键 —— 软件开发的基础、验收的依据</li><li>用户讲不清楚软件需求有哪些、是什么？</li><li>用户与软件工程师对软件需求理解存在偏差（对软件需求描述的<ins>歧义性、二义性、不准确</ins>等造成的）</li></ul></div></details><h3 id="原型模型prototype-model"><a class="anchor" href="#原型模型prototype-model">#</a> 原型模型 (Prototype Model)</h3><p><img data-src="https://img-blog.csdnimg.cn/20200415194559799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hleWk1MzUxMjMw,size_16,color_FFFFFF,t_70#pic_center" alt="原型模型和快速原型模型"></p><ul><li><p>软件原型作为交流载体和媒介 、<strong>支持用户参与到软件开发中</strong>持续、渐进地导出用户要求</p></li><li><p>适合于<strong>需求难导出、不易确定且持续变动</strong>的软件</p></li><li><p>缺点：对于分析人员要求高，既需要懂客户，也需要懂技术，还要懂管理，把握软件开发的约束性条件。</p></li></ul><h3 id="螺旋模型spiral-model"><a class="anchor" href="#螺旋模型spiral-model">#</a> 螺旋模型 (Spiral Model)</h3><p><img data-src="https://th.bing.com/th/id/R.6a4c152c7f77ca8f85a0df50cb3f7822?rik=BA0zoB0goNY76g&amp;riu=http%3a%2f%2fwww.uml.org.cn%2fSoftWareProcess%2fimages%2f20220228101.png&amp;ehk=l1AHyrClx59%2biqUXD2tBy8IcoEwCXMuopWawx2y4Jog%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="螺旋模型(Spiral Model)"></p><div class="note info"><p><strong>软件风险</strong>：使软件开发受到影响和损失、 甚至导致失败的、可能会发生的事件</p></div><ul><li>集成迭代模型和原型模型，<span class="red">引入风险分析，风险驱动的过程模型</span></li><li>每个迭代四个阶段，若干活动</li><li>适合于<strong>需求不明确、开发风险高、开发过程中需求变更大</strong>的软件项目</li><li>不足：管理复杂</li></ul><h3 id="不同软件模型的特点"><a class="anchor" href="#不同软件模型的特点">#</a> 不同软件模型的特点</h3><table><thead><tr><th>模型名称</th><th>指导思想</th><th>关注点</th><th>适合软件</th><th>管理难度</th></tr></thead><tbody><tr><td>瀑布模型</td><td>提供系统性指导</td><td>与软件生命周期相一致</td><td>需求变动不大、较为明确、易可预先定义的应用</td><td>易</td></tr><tr><td>原型模型</td><td>以原型为媒介指导用户的需求导出和确认</td><td>需求获取、导出和确认</td><td>理解需求难以表达清楚、不易导出和获取的应用</td><td>易</td></tr><tr><td>增量模型</td><td>快速交付和并行开发</td><td>软件详细设计、编码和测试的增量式完成</td><td>需求变动不大、较为明确、易可预先定义的应用</td><td>易</td></tr><tr><td>迭代模型</td><td>多次迭代，每次仅针对部分明确软件需求</td><td>分多次迭代来开发软件，每次仅关注部分需求</td><td>需求变动大、难以一次性说清楚的应用</td><td>中等</td></tr><tr><td>螺旋模型</td><td>集成迭代模型和原型模型，引入风险分析</td><td>软件计划制定和实现阶段，软件风险管理</td><td>开发风险大、需求难以确定的应用</td><td>难</td></tr></tbody></table><h2 id="敏捷软件开发方法agile-method"><a class="anchor" href="#敏捷软件开发方法agile-method">#</a> 敏捷软件开发方法 (Agile Method)</h2><p>重视人和交互、重视可运行软件系统、重视客户合作、重视响应用 户需求变化。少写软件文档，以代码为中心，快速响应变化</p><ul><li><p><strong>准则</strong></p><p>快速反馈、简单性假设、逐步修改、提倡更改、优质工作</p></li><li><p><strong>代表方法</strong></p><p>自适应开发、水晶方法、特征驱动开发、SCRUM、极限编程</p></li></ul><h2 id="summary-3"><a class="anchor" href="#summary-3">#</a> Summary</h2><ul><li><p><strong>软件开发需要过程指导</strong></p><p>明确步骤、活动、次序、关系</p></li><li><p><strong>多样化的软件过程模型</strong></p><p>瀑布、增量、迭代、原型、螺旋等</p></li><li><p>选择合适的软件过程模型</p><ul><li>考虑软件项目的特点和要求</li><li>结合软件过程模型的优缺点</li><li>考虑开发团队的经验和水平</li></ul></li></ul><h1 id="第四章-软件需求分析基础"><a class="anchor" href="#第四章-软件需求分析基础">#</a> 第四章 软件需求分析基础</h1><p>软件利益相关方→软件需求→软件开发→软件产品</p><p>软件利益相关方是软件需求的<span class="red"><strong>价值所在</strong></span></p><p>软件需求是软件开发的<span class="red"><strong>开发依据</strong></span>、是软件产品的<span class="red"><strong>验收标准</strong></span></p><h2 id="需求挖掘的来源利益相关方"><a class="anchor" href="#需求挖掘的来源利益相关方">#</a> 需求挖掘的来源：利益相关方</h2><p>利益相关方 (stakeholder)</p><ul><li>从软件系统中受益或与软件系统相关的<ins class="dot">人、组织或者系统</ins></li><li><strong>受益</strong>：使用、获益、盈利</li><li><strong>相关</strong>：发生操作和交互、存在关联性</li></ul><p>软件利益相关方的表现形式</p><ul><li><strong>用户</strong>：最终使用软件的人</li><li><strong>客户</strong>：从中获取利益的组织</li><li><strong>系统</strong>：与待开发系统进行交互的系统</li><li><strong>开发者</strong>：负责开发软件系统的人</li></ul><details class="info"><summary>实例</summary><div><p><strong>空巢老人看护软件的利益相关方</strong></p><ul><li>老人、家属、医生、投资方、机器人</li><li><ins>用户</ins>：<span class="spoiler" title="你知道得太多了">老人、家属、医生</span></li><li><ins>客户</ins>：<span class="spoiler" title="你知道得太多了">投资方</span></li><li><ins>系统</ins>：<span class="spoiler" title="你知道得太多了">机器人</span></li></ul></div></details><h2 id="软件需求的类别"><a class="anchor" href="#软件需求的类别">#</a> 软件需求的类别</h2><ul><li><p>软件<strong>功能性</strong>需求 (Functional)</p><p><strong>能够完成的功能</strong>及在某些场景下<strong>可展现的外部可见行为或效果</strong></p></li><li><p>软件<strong>质量方面</strong>的需求 (Quality)</p><ul><li><strong>外部质量属性</strong> 外部可展现的，<span class="red">用户、客户</span>等会非常关心，如<ins class="dot">运行性能、可靠性、易用性</ins>等</li><li><strong>内部质量属性</strong> 隐藏在内部的，<span class="red">软件开发工程师</span>会非常关心，如<ins class="dot">可扩展性、可维护性、可理解性</ins></li></ul></li><li><p>软件<strong>开发约束性</strong>需求 (Constraint)</p><p><strong>开发成本、交付进度、技术选型、遵循标准</strong>等方面提出的要求</p></li></ul><div class="note primary"><p><strong>非功能需求</strong>：产品需求（可用性、效率、可移植性等）、机构需求、外部需求（道德、法律）</p></div><ul><li><p><ins class="dot">获取软件需求方法</ins></p><p>访谈和会议、调查问卷、现场观摩、分析业务资料、软件原型、群体化方法（集思广益）</p></li></ul><h2 id="面向对象需求分析方法"><a class="anchor" href="#面向对象需求分析方法">#</a> 面向对象需求分析方法</h2><h3 id="需求工程"><a class="anchor" href="#需求工程">#</a> 需求工程</h3><p>通过一系列的<strong>过程、策略、方法学和工具</strong>尽可能获得<strong>准确、一致和完整</strong>的软件需求</p><blockquote><p>抽象、建模、分析</p></blockquote><h3 id="面相对象的4个要点"><a class="anchor" href="#面相对象的4个要点">#</a> 面相对象的 4 个要点</h3><ol><li>认为客观世界是由各种<strong>对象</strong>组成的，任何事物都是对象，复杂的对象可以由比较简单的对象以某种方式组合而成。</li><li>把所有对象都划分成<strong>各种对象类</strong>（类 CLASS），每个对象类都定义了一组数据和一组方法。</li><li>按照子类（派生类）和父类（基类）的<strong>继承</strong>关系，把若干个对象类组成一个层次结构的系统（类等级）。</li><li>对象彼此之间仅能通过传递消息互相联系。</li></ol><blockquote><p>万物皆对象</p><p>高度分工，高度复用，Only 消息传递</p></blockquote><div class="note primary"><p>面向对象 = 对象 + 类 + 继承 + 传递消息</p><p>只有同时使用对象，类，继承，消息的方法才是真正面相对象方法</p><p>对象 + 传递消息 = <span class="spoiler bulr" title="你知道得太多了">基于对象的方法</span> 类 + 继承 =<span class="spoiler bulr" title="你知道得太多了"> 基于类的方法</span></p></div><h4 id="对象object属性attribute方法method"><a class="anchor" href="#对象object属性attribute方法method">#</a> 对象 (Object)，属性（Attribute），方法（Method）</h4><ul><li>对象：对象是具体、有意义的、存在的实体</li><li>属性 (Attribute)：对象的性质，其值定义了对象<strong>状态</strong></li><li>操作 (Operation)：也称方法，对象行为，表示对象提供的<strong>服务</strong></li></ul><h4 id="面向对象的概念-类class与实例instance"><a class="anchor" href="#面向对象的概念-类class与实例instance">#</a> 面向对象的概念 - 类（Class）与实例（Instance）</h4><ul><li>类是对一组具有相同特征对象的抽象</li><li>对象与类的关系<ul><li>对象是类的实例，<ins class="dot">类是创建对象的模板</ins></li><li>类是静态的抽象；对象是动态、可运行的实体</li></ul></li></ul><h4 id="面向对象的概念-消息message"><a class="anchor" href="#面向对象的概念-消息message">#</a> 面向对象的概念 - 消息 (Message)</h4><ul><li><p>消息传递是实现对象间通讯和协作的基本手段</p><p>一个对象向另一个对象发送消息来请求其服务</p></li><li><p>消息描述：接收对象名、操作名和参数: received-obj.msg-name (para.)</p></li><li><p>消息类型</p><ul><li>同步消息：请求者需要<strong>等待响应者的处理结果</strong></li><li>异步消息：请求者发出消息后继续工作，<strong>无需等待</strong></li></ul></li></ul><h3 id="面向对象的核心概念"><a class="anchor" href="#面向对象的核心概念">#</a> 面向对象的核心概念</h3><h4 id="封装encapsulation"><a class="anchor" href="#封装encapsulation">#</a> 封装（Encapsulation）</h4><p>面向对象的程序中把数据和实现操作的代码集中起来放在对象内部。 使用一个对象的时候，只需知道它向外界提供的接口形式，而<ins>无需知道它的数据结构细节和实现操作的算法</ins>。</p><p>具有封装性的条件：</p><ul><li>有一个清晰的边界；</li><li>有明确的接口；</li><li>受保护的内部实现</li></ul><h4 id="继承inheritance"><a class="anchor" href="#继承inheritance">#</a> 继承（Inheritance）</h4><ul><li>表示类与类间的一般与特殊关系</li><li>子 (特殊) 类可共享父 (一般) 类的属性和操作</li><li>借助继承可形成系统的<strong>层次化</strong>类结构</li></ul><p><strong>继承的传递性</strong>：继承具有传递性，如果类 C 继承类 B，类 B 继承类 A，则类 C 继承类 A。</p><p><img data-src="https://www.itbaizhan.com/wiki/imgs/2661477-20220117165638615-1773617277.png" alt="类的继承"></p><div class="note primary"><p><strong>uml: 直线三角空心箭头 指向父类</strong></p></div><h5 id="多态性"><a class="anchor" href="#多态性">#</a> <span class="red"><strong>多态性</strong></span></h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Animal makes a sound"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog barks"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Cat</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Cat meows"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PolymorphismExample</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token class-name">Animal</span> animal1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token class-name">Animal</span> animal2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        animal1<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Dog barks</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        animal2<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cat meows</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        </pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token class-name">Animal</span> ref<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        ref <span class="token operator">=</span> animal1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        ref<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Dog barks</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        </pre></td></tr><tr><td data-num="32"></td><td><pre>        ref <span class="token operator">=</span> animal2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        ref<span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Cat meows</span></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><div class="note info"><p>可以通过父类实例化子类，或者引用子类</p></div><details class="success"><summary>多态性</summary><div><p>多态是面向对象编程的重要特性之一，它允许不同类型的对象对同一消息作出不同的响应。通过父类引用指向子类对象，可以在运行时根据实际的对象类型来决定调用哪个具体的方法实现，增加了程序的灵活性和可扩展性。</p></div></details><details class="primary"><summary>this指针</summary><div><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Animal makes a sound"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callMakeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeSound</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Dog barks"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">//    @Override</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">//    public void callMakeSound() &#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">//       System.out.println("In Dog's showThis(), this is a Dog object.");</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token comment">//        // 调用父类的方法，展示不同的 this</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token comment">//        super.showThis();</span></pre></td></tr><tr><td data-num="21"></td><td><pre><span class="token comment">//    &#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><div class="note info"><p>this 指针严格执行本体函数，而非覆盖过后的</p><p>super 严格指向父类，而非覆盖后的</p></div></div></details><p><ins class="dot purple"><strong>对象声明</strong>是为对象的<strong>引用</strong>创建一个空间，而<strong>对象生成</strong>则是创建一个类的实例，即为对象分配空间，并将对象空间的地址赋给其引用</ins></p><h5 id="引用"><a class="anchor" href="#引用">#</a> <span class="red"><strong>引用</strong></span></h5><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PolymorphismExample</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>		<span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  a 是 A 类型的引用， 但对象是 B 类型（这里 B 是 A 的子类）</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">)</span>a<span class="token punctuation">;</span> <span class="token comment">// 将 a 转为 B 的引用</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        b<span class="token punctuation">.</span><span class="token function">fun3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//fun3 是 B 独自实现的，正确</span></pre></td></tr><tr><td data-num="6"></td><td><pre>       	<span class="token comment">// A a = new A (); //  a 是 A 类型的引用， 但对象是 A 类型（这里 B 是 A 的子类）</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token comment">// B b = (B) a; // 将 a 转为 B 的引用</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token comment">//b.fun3 (); //fun3 是 B 独自实现的，错误，对象是 A 没有 B 的方法！！</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>“引用”<strong> 所能够调用的 “方法” 取决于 “引用” 的类型</strong>， 而该 “方法” 如何<strong>具体实现</strong>取决于<span class="dot red"><strong> &quot;对象&quot; 的类型</strong></span></p><h4 id="覆盖override"><a class="anchor" href="#覆盖override">#</a> 覆盖 (Override)</h4><p>子类<strong>增加或重新定义</strong>所继承的属性或方法，从而用新定义的属性和方法来覆盖所继承的、来自父类中的属性或方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span>｛</pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token class-name">String</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> 	<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> 		<span class="token keyword">return</span> “<span class="token class-name">Value</span> is<span class="token operator">:</span>” <span class="token operator">+</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> 	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>｝</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre> 	<span class="token class-name">String</span> address<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> 	<span class="token keyword">public</span> <span class="token class-name">String</span> getValue <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> 		<span class="token keyword">return</span> “<span class="token class-name">Value</span> is<span class="token operator">:</span>” <span class="token operator">+</span> address<span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">// 子类 B 重新定义所继承的方法 getValue</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="重载overload"><a class="anchor" href="#重载overload">#</a> 重载 (Overload)</h4><p>一个类中有多个同名操作，但它们在操作数或操作数类型上有区别，系统根据实参引用不同方法</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token class-name">Public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre> 	<span class="token keyword">int</span> age<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> 	<span class="token class-name">String</span> name<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token keyword">int</span> agePara<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre> 		age <span class="token operator">=</span> agePara<span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> 	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setValue</span><span class="token punctuation">(</span><span class="token class-name">String</span> namePara<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>		name <span class="token operator">=</span> namePara<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="初步软件需求"><a class="anchor" href="#初步软件需求">#</a> 初步软件需求</h3><h4 id="自然语言描述"><a class="anchor" href="#自然语言描述">#</a> 自然语言描述</h4><p>自然语言是最为常用的需求描述手段；描述软件的功能性需求、质量需求和开发约束需求等</p><ul><li>不具体</li><li>不准确</li><li>有二义</li><li>不直观</li></ul><h4 id="软件原型描述"><a class="anchor" href="#软件原型描述">#</a> 软件原型描述</h4><ul><li>优势<ul><li>直观、可展示和可操作</li></ul></li><li>不足<ul><li>主要以操作界面的形式展示软件需求的 梗概，主要是软件与用户之间的输入和 输出，业务的大致流程，<strong>无法描述软件需求的具体细节</strong></li></ul></li></ul><h4 id="uml-建模语言描述"><a class="anchor" href="#uml-建模语言描述">#</a> UML 建模语言描述</h4><ul><li>Unified (统一)：提取不同方法中最好建模技术，如 OMT (James Rumbaugh)，Booch method (Grady Booch ) 和 OOSE (Ivar Jacobson)；采用统一、标准化的表示方式，支持不同 人员之间的交流；</li><li>Modeling (建模)：基于面向对象的概念和抽象，对现实系统和软件系统进行可视化建模； 、</li><li>Language (语言)：提供图形化的图符，用来表示软件系统的一种语言。</li></ul><table><thead><tr><th>视点</th><th>图 (diagram)</th><th>说明</th></tr></thead><tbody><tr><td>结构</td><td>包图 (package diagram)</td><td>从包层面描述系统的静态结构</td></tr><tr><td></td><td>类图 (class diagram)</td><td>从类层面描述系统的静态结构</td></tr><tr><td></td><td>对象图 (object diagram)</td><td>从对象层面描述系统的静态结构</td></tr><tr><td></td><td>构件图 (component diagram)</td><td>描述系统中构件及其依赖关系</td></tr><tr><td></td><td>状态图 (statechart diagram)</td><td>描述状态的变迁</td></tr><tr><td>行为</td><td>活动图 (activity diagram)</td><td>描述系统活动的实现</td></tr><tr><td></td><td>通信图 (communication diagram)</td><td>描述对象间的消息传递与协作</td></tr><tr><td></td><td>顺序图 (sequence diagram)</td><td>描述对象间的消息传递与协作</td></tr><tr><td>部署</td><td>部署图 (deployment diagram)</td><td>描述系统在工作在物理运行环境中的部署情况</td></tr><tr><td>用例图</td><td>用例图 (use case diagram)</td><td>从外部用户角度描述系统功能</td></tr></tbody></table><h4 id="ruprational-unified-process"><a class="anchor" href="#ruprational-unified-process">#</a> RUP（Rational Unified Process）</h4><ul><li><strong>初始阶段</strong>主要任务是理解和分析 需求，生成用例模型框架；</li><li><strong>精化阶段</strong>是完成高优先级的用例 开发，完善用例模型；</li><li><strong>构建阶段</strong>真是多次迭代，完成不 同优先级用例开发；</li><li><strong>交付阶段</strong>则是进行各种功能，性 能测试，进行产品化部署，完成 系统开发。</li></ul><h3 id="用例图描述"><a class="anchor" href="#用例图描述">#</a> 用例图描述</h3><p>用例：文本形式的情节描述，用以说明某参与者使用系统以实现某一特定目标的情形，描述的是外部行为者所理解的系统功能。</p><p>用例建模：用于描述一个系统应该做什么（功能需求），用用例图来描述 (可能有多幅)</p><p>用例图：把系统看做黑盒子，给出了用户所感受到的系统行为，<ins>但不描述系统如何实现该功能</ins>，驱动了需求分析之后各阶段的开发工作。</p><h4 id="用例建模"><a class="anchor" href="#用例建模">#</a> 用例建模</h4><p>在 UML 中，用例图的主要元素是系统、用例、行为者以及用例之间的关系：</p><ul><li>系统边界、用例</li><li>执行者 (参与者)：可能使用这些用例的人或外部系统，参与者与用例连接表示参与者使用了该用例</li><li>模型元素间关系：<ins>关联、扩展、包含、泛化</ins>等</li></ul><h5 id="系统"><a class="anchor" href="#系统">#</a> 系统</h5><p>代表系统的方框的边线表示系统的边界，用于划定系统的功能范围、定义了系统所具有的功能</p><p>描述该系统功能的用例置于方框内，代表外部实体的行为都置于方框外</p><h5 id="执行者actor"><a class="anchor" href="#执行者actor">#</a> 执行者 (Actor)</h5><p>行为者是指与系统交互的人或其他系统，它代表外部实体</p><p><ins>在用例图中，<strong>连接行为者和用例的直线</strong>，表示两者之间交换信息，称为通信联系</ins></p><p>单个行为者可与多个用例联系，一个用例也可与多个行为者联系</p><h5 id="用例use-case"><a class="anchor" href="#用例use-case">#</a> 用例 (Use Case)</h5><p>用例是一个类，它代表一类功能而不是使用该功能的某个具体实例</p><ul><li>用例代表某些用户可见的功能，实现一个具体的用户目标；</li><li>用例总是被行为者启动的，并向行为者提供可识别的值；</li><li>用例必须是完整的</li></ul><blockquote><p>通常把用例的实例称为脚本</p></blockquote><h5 id="用例间的关系"><a class="anchor" href="#用例间的关系">#</a> 用例间的关系</h5><ul><li><p>扩展关系</p><p>向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关系就是扩展关系 。后者继承前者的一些行为，通常把后者称为扩展用例，用例之间的扩展关系图示为带构造型 &lt;&lt;extend&gt;&gt; 的关系 <code>--&gt;</code></p></li><li><p>包含关系</p><p>当一个用例包含另一个用例的全部步骤时，这两个用例之间就构成了包含关系，用带构造型 &lt;&lt;include&gt;&gt; 的关系 <code>--&gt;</code></p></li><li><p>泛化关系</p><p>一个一般用况与一个更特殊的用况之间的关系，特殊用况可继承一般用况的特征，用 <code>—▷</code> 表示</p></li></ul><p><img data-src="https://image.woshipm.com/wp-files/2021/06/ogjiS2n2L5tXMxsyBaLW.png" alt="用例图"></p><div class="note info"><p><strong>步骤</strong>：定义系统 (总体范围)；确定参与者；确定用例；描述用例；定义用例间的关系；确认 模型。</p></div><h1 id="第五章-软件分析"><a class="anchor" href="#第五章-软件分析">#</a> 第五章 软件分析</h1><p>顺序图、类图、状态图</p><p>分析软件需求过程</p><p>软件需求文档</p><h2 id="软件分析的任务"><a class="anchor" href="#软件分析的任务">#</a> 软件分析的任务</h2><p>基于初步软件需求，进一步精化和分析软件需求，确定软件需求优先级，建立软件需求模型，发现和解决软件需求缺陷，形成高质量的软件需求模型和软件需求规格说明书</p><h3 id="类图"><a class="anchor" href="#类图">#</a> 类图</h3><p>类名 、属性 、操作</p><p><img data-src="https://www.iyunying.org/wp-content/uploads/2017/05/45cef248917ef234ae43602b1b86c6a6.png" alt="UML建模之类图"></p><p><strong>结点</strong>：表示系统中的 类（或接口）及其属 性和操作</p><p><strong>边</strong>：类之间的关系</p><div class="note primary"><p>在 UML 类图中，常见的有以下几种关系: <ins>泛化（Generalization）, 实现 （Realization），关联（Association)，聚合（Aggregation），组合 (Composition)，依赖 (Dependency)。</ins></p><p><strong>各种关系的强弱顺序</strong>： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p></div><p>在 UML（Unified Modeling Language）中，类之间有多种关系来表示不同的关联方式。</p><ol><li><strong>关联 (Association)</strong>：<ul><li>表示两个类之间的基本关系，通常是某个类包含对另一个类的引用。</li><li>关联可以是单向或双向的，表示对象之间的通信。</li><li><strong>符号</strong>：<ins>实线</ins>，可能有箭头（单向关联）或没有箭头（双向关联）。</li></ul></li></ol><ul><li><code>—</code></li></ul><ol start="2"><li><strong>聚合 (Aggregation)</strong>：<ul><li>表示 “整体 - 部分” 关系，<strong>但部分可以独立于整体存在</strong>。</li><li>例如，班级和学生之间的关系，学生属于班级，但学生可以独立存在。</li><li><strong>符号</strong>：带空心菱形的实线，菱形指向整体的一端。</li></ul></li></ol><ul><li><code>-◇</code></li></ul><ol start="3"><li><p><strong>组合 (Composition)</strong>：</p><ul><li>表示 “整体 - 部分” 关系，<strong>部分不能独立于整体存在</strong>。更强的一种整体与部分间的拥有关系，整体负责部 分的创建和删除</li><li>例如，房间和墙壁之间的关系，房间消失时，墙壁也随之消失。</li><li><strong>符号</strong>：带实心菱形的实线，菱形<ins>指向整体</ins>的一端。</li></ul></li></ol><ul><li><code>-◆</code></li></ul><ol start="4"><li><p><strong>继承 / 泛化 (Generalization)</strong>：</p><ul><li>表示类之间的 “is-a” 关系，子类继承父类的属性和方法。</li><li>例如，动物类和狗类之间的关系，狗是动物的一种。</li><li><strong>符号</strong>：空心三角形箭头<ins>指向父类</ins>。</li></ul></li></ol><ul><li><code>-▷</code></li></ul><ol start="5"><li><p><strong>实现 (Realization)</strong>：</p><ul><li>表示<strong>类与接口之间的关系，类实现接口的行为</strong>。</li><li>例如，飞行接口和鸟类之间的关系，鸟实现了飞行的接口。</li><li><strong>符号</strong>：带空心三角形的虚线箭头<ins>指向接口</ins>。</li></ul></li></ol><ul><li><code>- - - -▷</code></li></ul><ol start="6"><li><p><strong>依赖 (Dependency)</strong>：</p><ul><li>两个元素之间的依赖关系。</li><li>例如，方法中使用的参数类型或局部变量类型。</li><li><strong>符号</strong>：虚线箭头，箭头指向<ins>被依赖的类 / 被使用的类</ins>。</li></ul></li></ol><ul><li><code>---&gt;</code></li></ul><div class="note info"><p><ins>注意数字关系</ins></p></div><p><img data-src="https://th.bing.com/th/id/R.e3ee50211906b275e39bce30dfd4f098?rik=p%2fP22fLso6wNQw&amp;riu=http%3a%2f%2fstatic.codingwhy.com%2fcms%2f20160612%2f1465734116852034956.jpg&amp;ehk=siVFWC1mQO6OnCB707A2tY95YUc5VhfKAd0KAOkHnp4%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="UML类图"></p><h3 id="状态图"><a class="anchor" href="#状态图">#</a> 状态图</h3><p><strong>状态图</strong>：是一种由状态、变迁、事件和活动组成的状态机，用来描述类的对象所有可能的状态以及时间发生时状态的转移条件。</p><p><strong>状态变量</strong>：是状态机图所显示的类的属性，也可以是临时变量</p><p><strong>活动</strong>：列出了处于该状态时要执行的事件和动</p><p>UML 状态图（State Diagram）用于描述对象在生命周期中的状态变化，尤其是在响应事件或条件时的变化。它适合用于模型化具有明确状态转换的复杂对象行为，通常用于描述单个对象的状态机。</p><h4 id="uml状态图的基本组成要素"><a class="anchor" href="#uml状态图的基本组成要素">#</a> UML 状态图的基本组成要素</h4><ol><li><p><strong>状态 (State)</strong>：</p><ul><li><strong>表示对象在生命周期中的某个特定状态或条件</strong>。状态用带标签的<strong>矩形框</strong>表示。</li><li>每个状态可以包含进入活动 (entry action)、退出活动 (exit action)、内部活动 (internal activity)、以及子状态。</li></ul></li><li><p><strong>初始状态 (Initial State)</strong>：</p><ul><li>表示对象在<strong>生命周期中的起始状态</strong>。用一个<strong>填充的黑色圆圈</strong>表示。</li><li>初始状态<ins>指向第一个有效的状态</ins>。</li></ul></li><li><p><strong>终止状态 (Final State)</strong>：</p><ul><li>表示<strong>对象生命周期的结束</strong>。用一个黑色圆圈，外部包裹一个空心圆圈来表示。</li><li>当状态机到达终止状态时，对象的生命周期就结束了。</li></ul></li><li><p><strong>转换 (Transition)</strong>：</p><ul><li>表示状态之间的转换关系，即对象在满足某些条件或事件触发时从一个状态迁移到另一个状态。</li><li>转换用带箭头的线表示，并可标注触发事件、条件守护 (guard condition)、以及动作 (action)。</li><li>例如： <code>事件名[条件] / 动作</code> 。</li></ul></li><li><p><strong>事件 (Event)</strong>：</p><ul><li>是状态之间发生转换的触发因素，可能是用户输入、方法调用或系统触发。</li><li>事件通常写在转换箭头旁边。</li></ul></li><li><p><strong>动作 (Action)</strong>：</p><ul><li>是在状态转换过程中执行的活动。可以在转换箭头上标注执行的动作。</li></ul></li><li><p><strong>子状态 (Substate)</strong>：</p><ul><li>状态图支持嵌套状态，称为复合状态 (Composite State)。复合状态中包含的子状态可以是顺序 (Sequential) 的，也可以是并行 (Concurrent) 的。</li></ul></li></ol><blockquote><p>复杂状态机行为的系统时非常有用，比如电梯控制系统、交易处理系统等。</p></blockquote><p><img data-src="https://pic3.zhimg.com/v2-a1bd2ebdc21060b28c867a04d55f802a_1440w.jpg?source=172ae18b" alt="UML状态图详解 - 知乎"></p><h4 id="顺序图"><a class="anchor" href="#顺序图">#</a> 顺序图</h4><p>交互图的一种，描述了对象之间消息发送的先后顺序，<strong>强调时间顺序</strong>。序列图的主要用途是把用例表达的需求，转化为进一步、更加正式层次的精细表达。用例常常被细化为一个或者更多的序列图。同时序列图更有效地描述如何分配各个类的职责以及各类具有相应职责的原因。</p><ul><li>描述对象间的消息交互序列<ul><li><strong>纵向</strong>：时间轴，对象及其<ins>生命线</ins> (虚线)，活跃期 (长条矩形)</li><li><strong>横向</strong>：对象间的消息传递，用一个矩形框表示，框内标有对象名。名称可带下划线，意味 着序列图中的生命线代表<ins>一个类的特定实例</ins>。</li><li><ins>对象间的通信用对象生命线之间的水平消息线来表示</ins>，消息箭头的形状表明消息的类型。 箭头以时间顺序在图中从上到下排列。</li></ul></li></ul><h2 id="软件分析过程"><a class="anchor" href="#软件分析过程">#</a> 软件分析过程</h2><h3 id="面向对象分析"><a class="anchor" href="#面向对象分析">#</a> 面向对象分析</h3><p>面向对象分析，就是<strong>抽取和整理用户需求</strong>，并<strong>建立问题域精确模型的过程</strong>。</p><p>面向对象建模得到的模型包含对象的<strong>三个要素（子模型）</strong>：静态结构（对象模型）， 交互次序（动态模型），和数据变换（功能模型）。</p><ul><li><p>对象模型</p><p>定义做事情的实体 —— 静态<span class="red"><strong>数据结构</strong></span></p><p>用例图</p></li><li><p>动态模型</p><p>规定什么时候做 ——<span class="red"><strong> 执行操作</strong></span></p><p>状态图、序列图、活动图</p></li><li><p>功能模型</p><p>系统应该做什么 ——<span class="red"><strong> 数值变化</strong></span></p><p>用例图</p></li></ul><div class="note info"><p><strong>用面向对象方法开发软件，在任何情况下，对象模型始终都是<ins>最重要、最基 本、最核心</ins>的</strong></p></div><h3 id="构建对象模型"><a class="anchor" href="#构建对象模型">#</a> 构建对象模型</h3><p>复杂问题（大型系统）的对象模型由下述五个层次组成：<span class="red"><strong>主题层（范畴层）、结构层， 类 --&amp;-- 对象层，属性层和服务层。</strong></span></p><ul><li>找出类 -&amp;- 对象；定义属性；定义服务；识别结构；识别主题；反复修改。</li></ul><details class="info"><summary>定义结构</summary><div><p><strong>对象（以及它们的类）与外部的关系有如下四种：</strong></p><p>（1）一般 - 特殊关系（<ins>继承关系</ins>）：即对象之间的分类关系，用一般 - 特殊结构表示；</p><p>（2）整体 - 部分关系：即对象之间的<ins>组成关系</ins>，用整体 - 部分结构表示；</p><p>（3）静态连接关系：即通过对象属性所反映出来的联系，用<ins>实例连接</ins>表 示；</p><p>（4）动态连接关系：即对象行为之间的依赖关系，用<ins>消息连接</ins>表示。</p></div></details><h3 id="动态模型"><a class="anchor" href="#动态模型">#</a> 动态模型</h3><p>每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件合并起 来（交互图），从而构成系统的动态模型。</p><p>动态模型是基于事件共享而互相关联的一组状态图的集合。</p><p>行为分类</p><ol><li><p>系统行为 — 如创建、删除、复制、转存。</p></li><li><p>对象自身的简单行为 — 如读、写属性值。</p></li><li><p>对象自身的复杂行为 — 如计算或监控。</p></li></ol><h3 id="功能模型"><a class="anchor" href="#功能模型">#</a> 功能模型</h3><p>功能模型表示变化的系统的 “功能” 性质，它指明了系统应该 “做什么”，因此更直接地反映了用户对目标系统的需求。</p><p>功能模型由一组数据流图组成。一般说来，与对象模型和动态模型比较起来，数据流图并没有增加新的信息，但是建立功能模型有助于软件开发人员更深入地理解问题域，改进和完善自己的设计。</p><h3 id="小结"><a class="anchor" href="#小结">#</a> 小结</h3><p>三个模型从三个不同的角度对所要开发的系统进行了描述，三个模型<strong>相互补充、相互配合，使得开发人员能够更全面的认识系统。</strong></p><ul><li><p>对象模型：以对象、属性、关系和操作形式描述系统结构；</p></li><li><p>动态模型：描述系统的内部行为；</p></li><li><p>功能模型：从户用的观点描述系统功能。</p></li></ul><p><ins class="dot">功能模型指出发生了什么，动态模型确定什么时候发生，而对象模型确定发生的客体。</ins></p><h2 id="summary-4"><a class="anchor" href="#summary-4">#</a> Summary</h2><ul><li>分析软件是要精化和深化软件需求<ul><li>基于初步软件需求，循序渐进</li><li>确保软件需求的<ins>完整性、一致性和准确性</ins></li></ul></li><li>UML 提供的、用于描述<ins>软件需求</ins>的图<ul><li>用例图、交互图、分析类图、状态图</li></ul></li><li>软件需求分析的难点<ul><li>软件需求不易捕获</li><li>软件变化是无可避免</li></ul></li></ul><div class="note primary"><p>需求变更永无停止！！！</p></div><div class="tags"><a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-28 14:03:45" itemprop="dateModified" datetime="2024-10-28T14:03:45+08:00">2024-10-28</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Suivez <i class="ic i-at"><em>@</em></i>Shoka</li><li class="link"><strong>本文链接：</strong> <a href="http://example.com/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" title="软件工程导论">http://example.com/2024/10/21/ComputerScience/软件工程导论/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/05/02/Mathematics/%E9%87%8D%E7%A7%AF%E5%88%86/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;images8.alphacoders.com&#x2F;127&#x2F;1276444.png" title="未命名"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div><div class="item right"><a href="/2024/10/21/papernote/EfficientExactSubgraph/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;images3.alphacoders.com&#x2F;119&#x2F;1192690.jpg" title="Efficient Exact Subgraph Matching via GNN-based Path Dominance Embedding"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> vldb</span><h3>Efficient Exact Subgraph Matching via GNN-based Path Dominance Embedding</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%8F%8A%E5%85%B6%E7%89%B9%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">第一章 软件及其特点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">软件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">软件生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.2.</span> <span class="toc-text">软件特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.3.</span> <span class="toc-text">软件分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">开源软件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">软件质量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%BD%AF%E4%BB%B6%E7%89%B9%E5%BE%81%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.4.</span> <span class="toc-text">当前软件特征的变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary"><span class="toc-number">1.5.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8F%91%E5%B1%95%E8%84%89%E7%BB%9C"><span class="toc-number">2.</span> <span class="toc-text">第二章 软件工程发展脉络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">软件工程产生背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%9F%BA%E6%9C%AC%E5%86%85%E6%B6%B5"><span class="toc-number">2.2.</span> <span class="toc-text">软件工程基本内涵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">何为软件工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.2.2.</span> <span class="toc-text">软件工程三要素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%AD%A6"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">方法学</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.2.3.</span> <span class="toc-text">软件开发的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">软件工程的发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%8F%91%E5%B1%95%E7%9A%84%E6%8A%80%E6%9C%AF%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.1.</span> <span class="toc-text">软件工程发展的技术特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-2"><span class="toc-number">2.4.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">第三章 软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">何为软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.1.1.</span> <span class="toc-text">软件开发的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">软件过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B-software-process-model"><span class="toc-number">3.1.3.</span> <span class="toc-text">软件过程模型 Software Process Model</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">有哪些软件过程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B-waterfall-model"><span class="toc-number">3.2.1.</span> <span class="toc-text">瀑布模型 Waterfall Model</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#waterfall"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">Waterfall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#detail"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">Detail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limitation"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">Limitation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E7%9A%84%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B%E5%B8%A6%E5%8F%8D%E9%A6%88%E5%92%8C%E5%9B%9E%E6%BA%AF"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">改进的瀑布模型：带反馈和回溯</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8Bincremental-model"><span class="toc-number">3.2.2.</span> <span class="toc-text">增量模型 (Incremental Model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8Biterative-model"><span class="toc-number">3.2.3.</span> <span class="toc-text">迭代模型 (Iterative Model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8Bprototype-model"><span class="toc-number">3.2.4.</span> <span class="toc-text">原型模型 (Prototype Model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8Bspiral-model"><span class="toc-number">3.2.5.</span> <span class="toc-text">螺旋模型 (Spiral Model)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%BD%AF%E4%BB%B6%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.2.6.</span> <span class="toc-text">不同软件模型的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95agile-method"><span class="toc-number">3.3.</span> <span class="toc-text">敏捷软件开发方法 (Agile Method)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-3"><span class="toc-number">3.4.</span> <span class="toc-text">Summary</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">第四章 软件需求分析基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E6%8C%96%E6%8E%98%E7%9A%84%E6%9D%A5%E6%BA%90%E5%88%A9%E7%9B%8A%E7%9B%B8%E5%85%B3%E6%96%B9"><span class="toc-number">4.1.</span> <span class="toc-text">需求挖掘的来源：利益相关方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">软件需求的类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">面向对象需求分析方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%B7%A5%E7%A8%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">需求工程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E7%9B%B8%E5%AF%B9%E8%B1%A1%E7%9A%844%E4%B8%AA%E8%A6%81%E7%82%B9"><span class="toc-number">4.3.2.</span> <span class="toc-text">面相对象的 4 个要点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1object%E5%B1%9E%E6%80%A7attribute%E6%96%B9%E6%B3%95method"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">对象 (Object)，属性（Attribute），方法（Method）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5-%E7%B1%BBclass%E4%B8%8E%E5%AE%9E%E4%BE%8Binstance"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">面向对象的概念 - 类（Class）与实例（Instance）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5-%E6%B6%88%E6%81%AFmessage"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">面向对象的概念 - 消息 (Message)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">4.3.3.</span> <span class="toc-text">面向对象的核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85encapsulation"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">封装（Encapsulation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFinheritance"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">继承（Inheritance）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">4.3.3.2.1.</span> <span class="toc-text">多态性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">4.3.3.2.2.</span> <span class="toc-text">引用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%86%E7%9B%96override"><span class="toc-number">4.3.3.3.</span> <span class="toc-text">覆盖 (Override)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDoverload"><span class="toc-number">4.3.3.4.</span> <span class="toc-text">重载 (Overload)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%BD%AF%E4%BB%B6%E9%9C%80%E6%B1%82"><span class="toc-number">4.3.4.</span> <span class="toc-text">初步软件需求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.4.1.</span> <span class="toc-text">自然语言描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8E%9F%E5%9E%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.4.2.</span> <span class="toc-text">软件原型描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uml-%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.4.3.</span> <span class="toc-text">UML 建模语言描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ruprational-unified-process"><span class="toc-number">4.3.4.4.</span> <span class="toc-text">RUP（Rational Unified Process）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.5.</span> <span class="toc-text">用例图描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%BB%BA%E6%A8%A1"><span class="toc-number">4.3.5.1.</span> <span class="toc-text">用例建模</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.3.5.1.1.</span> <span class="toc-text">系统</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%80%85actor"><span class="toc-number">4.3.5.1.2.</span> <span class="toc-text">执行者 (Actor)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BE%8Buse-case"><span class="toc-number">4.3.5.1.3.</span> <span class="toc-text">用例 (Use Case)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">4.3.5.1.4.</span> <span class="toc-text">用例间的关系</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">第五章 软件分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.1.</span> <span class="toc-text">软件分析的任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE"><span class="toc-number">5.1.1.</span> <span class="toc-text">类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%9B%BE"><span class="toc-number">5.1.2.</span> <span class="toc-text">状态图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uml%E7%8A%B6%E6%80%81%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">UML 状态图的基本组成要素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">顺序图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.</span> <span class="toc-text">软件分析过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90"><span class="toc-number">5.2.1.</span> <span class="toc-text">面向对象分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.2.</span> <span class="toc-text">构建对象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.3.</span> <span class="toc-text">动态模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">功能模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.2.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#summary-4"><span class="toc-number">5.3.</span> <span class="toc-text">Summary</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" rel="bookmark" title="软件工程导论">软件工程导论</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Suivez" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Suivez</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">16</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">10</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">7</span> <span class="name">标签</span></a></div></nav><div class="social"></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/05/02/Mathematics/%E9%87%8D%E7%A7%AF%E5%88%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/10/21/papernote/EfficientExactSubgraph/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/zhaji/" title="分类于 札记">札记</a></div><span><a href="/2023/04/06/zhaji/%E7%9C%8B%E5%88%B0%E7%B1%BB%E8%84%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E7%9A%84%E6%84%9F%E5%8F%B9/" title="看到类脑计算机发展的感叹">看到类脑计算机发展的感叹</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Mathematics/" title="分类于 Mathematics">Mathematics</a></div><span><a href="/2023/03/19/Mathematics/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%BA%8C/" title="数学笔记二">数学笔记二</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Mathematics/" title="分类于 Mathematics">Mathematics</a></div><span><a href="/2023/03/19/Mathematics/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0%E4%B8%80/" title="高等数学笔记一">高等数学笔记一</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/papernote/" title="分类于 论文读记">论文读记</a></div><span><a href="/2024/10/24/papernote/EventPromoteInhibitRelationMining/" title="EventPromoteInhibitRelationMining">EventPromoteInhibitRelationMining</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/" title="分类于 计算机科学">计算机科学</a></div><span><a href="/2024/10/25/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/zhaji/" title="分类于 札记">札记</a></div><span><a href="/2022/09/08/zhaji/EnglishClass/" title="My fist English Class">My fist English Class</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/websecurity/" title="分类于 网络安全">网络安全</a> <i class="ic i-angle-right"></i> <a href="/categories/websecurity/CTF/" title="分类于 CTF">CTF</a></div><span><a href="/2024/10/25/WebSecurity/CTF/CTF%E9%A2%98%E7%9B%AE%E7%AC%94%E8%AE%B0/" title="CTFNote">CTFNote</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/05/02/Mathematics/%E9%87%8D%E7%A7%AF%E5%88%86/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/Mathematics/" title="分类于 Mathematics">Mathematics</a></div><span><a href="/2023/03/19/Mathematics/%E9%94%99%E9%A2%98%E6%9C%AC/" title="错题本">错题本</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerscience/" title="分类于 计算机科学技术">计算机科学技术</a></div><span><a href="/2024/10/21/ComputerScience/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/" title="软件工程导论">软件工程导论</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Suivez @ Suivez Shoka</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2024/10/21/ComputerScience/软件工程导论/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,mermaid:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->